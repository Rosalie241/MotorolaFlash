diff --git a/host/windows/usb/api/AdbWinApi.cpp b/host/windows/usb/api/AdbWinApi.cpp
index 507a2b59d..eaf820982 100644
--- a/host/windows/usb/api/AdbWinApi.cpp
+++ b/host/windows/usb/api/AdbWinApi.cpp
@@ -1,112 +1,78 @@
-/*
- * Copyright (C) 2008 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-// AdbWinApi.cpp : Implementation of DLL Exports.
-
-#include "stdafx.h"
-#include "adb_api.h"
-#include "adb_winusb_api.h"
-
-extern "C" {
-int _forceCRTManifest;
-int _forceMFCManifest;
-int _forceAtlDllManifest;
-};
-
-/// References InstantiateWinUsbInterface declared in adb_api.cpp
-extern PFN_INSTWINUSBINTERFACE InstantiateWinUsbInterface;
-
-class CAdbWinApiModule : public CAtlDllModuleT< CAdbWinApiModule > {
- public:
-  CAdbWinApiModule()
-      : CAtlDllModuleT< CAdbWinApiModule >(),
-        adbwinusbapi_handle_(NULL),
-        is_initialized_(false) {
-  }
-
-  ~CAdbWinApiModule() {
-    // Unload AdbWinUsbApi.dll before we exit
-    if (NULL != adbwinusbapi_handle_) {
-      FreeLibrary(adbwinusbapi_handle_);
-    }
-  }
-
-  /** \brief Loads AdbWinUsbApi.dll and caches its InstantiateWinUsbInterface
-    export.
-
-    This method is called from DllMain on DLL_PROCESS_ATTACH event. In this
-    method we will check if WINUSB.DLL required by AdbWinUsbApi.dll is
-    installed, and if it is we will load AdbWinUsbApi.dll and cache address of
-    InstantiateWinUsbInterface routine exported from AdbWinUsbApi.dll
-  */
-  void AttachToAdbWinUsbApi() {
-    // We only need to run this only once.
-    if (is_initialized_) {
-      return;
-    }
-
-    // Just mark that we have ran initialization.
-    is_initialized_ = true;
-
-    // Before we can load AdbWinUsbApi.dll we must make sure that WINUSB.DLL
-    // has been installed. Build path to the file.
-    wchar_t path_to_winusb_dll[MAX_PATH+1];
-    if (!GetSystemDirectory(path_to_winusb_dll, MAX_PATH)) {
-      return;
-    }
-    wcscat(path_to_winusb_dll, L"\\WINUSB.DLL");
-
-    if (0xFFFFFFFF == GetFileAttributes(path_to_winusb_dll)) {
-      // WINUSB.DLL is not installed. We don't (in fact, can't) load
-      // AdbWinUsbApi.dll
-      return;
-    }
-
-    // WINUSB.DLL is installed. Lets load AdbWinUsbApi.dll and cache its
-    // InstantiateWinUsbInterface export.
-    // We require that AdbWinUsbApi.dll is located in the same folder
-    // where AdbWinApi.dll and adb.exe are located, so by Windows
-    // conventions we can pass just module name, and not the full path.
-    adbwinusbapi_handle_ = LoadLibrary(L"AdbWinUsbApi.dll");
-    if (NULL != adbwinusbapi_handle_) {
-      InstantiateWinUsbInterface = reinterpret_cast<PFN_INSTWINUSBINTERFACE>
-          (GetProcAddress(adbwinusbapi_handle_, "InstantiateWinUsbInterface"));
-    }
-  }
-
- protected:
-  /// Handle to the loaded AdbWinUsbApi.dll
-  HINSTANCE adbwinusbapi_handle_;
-
-  /// Flags whether or not this module has been initialized.
-  bool      is_initialized_;
-};
-
-CAdbWinApiModule _AtlModule;
-
-// DLL Entry Point
-extern "C" BOOL WINAPI DllMain(HINSTANCE instance,
-                               DWORD reason,
-                               LPVOID reserved) {
-  // Lets see if we need to initialize InstantiateWinUsbInterface
-  // variable. We do that only once, on condition that this DLL is
-  // being attached to the process and InstantiateWinUsbInterface
-  // address has not been calculated yet.
-  if (DLL_PROCESS_ATTACH == reason) {
-    _AtlModule.AttachToAdbWinUsbApi();
-  }
-  return _AtlModule.DllMain(reason, reserved);
-}
+/*
+ * Copyright (C) 2008 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+// AdbWinApi.cpp : Implementation of DLL Exports.
+
+#include "stdafx.h"
+#include "adb_api.h"
+#include "adb_winusb_api.h"
+
+extern "C" {
+int _forceCRTManifest;
+int _forceMFCManifest;
+int _forceAtlDllManifest;
+};
+
+/// References InstantiateWinUsbInterface declared in adb_api.cpp
+extern PFN_INSTWINUSBINTERFACE InstantiateWinUsbInterface;
+
+// Globals
+HINSTANCE g_adbwinusbapi_handle;
+bool      g_is_initialized;
+bool      g_return;
+
+bool AttachToAdbWinUsbApi() {
+  // We only need to run this only once.
+  if (g_is_initialized) {
+    return g_return;
+  }
+
+  // Just mark that we have ran initialization.
+  g_is_initialized = true;
+
+  // Before we can load AdbWinUsbApi.dll we must make sure that WINUSB.DLL
+  // has been installed. Build path to the file.
+  wchar_t path_to_winusb_dll[MAX_PATH+1];
+  if (!GetSystemDirectoryW(path_to_winusb_dll, MAX_PATH)) {
+    g_return = false;
+    goto ret;
+  }
+  wcscat(path_to_winusb_dll, L"\\WINUSB.DLL");
+
+  if (0xFFFFFFFF == GetFileAttributesW(path_to_winusb_dll)) {
+    // WINUSB.DLL is not installed. We don't (in fact, can't) load
+    // AdbWinUsbApi.dll
+    g_return = false;
+    goto ret;
+  }
+
+  // WINUSB.DLL is installed. Lets load AdbWinUsbApi.dll and cache its
+  // InstantiateWinUsbInterface export.
+  // We require that AdbWinUsbApi.dll is located in the same folder
+  // where AdbWinApi.dll and adb.exe are located, so by Windows
+  // conventions we can pass just module name, and not the full path.
+  g_adbwinusbapi_handle = LoadLibraryW(L"AdbWinUsbApi.dll");
+  if (NULL != g_adbwinusbapi_handle) {
+    InstantiateWinUsbInterface = reinterpret_cast<PFN_INSTWINUSBINTERFACE>
+      (GetProcAddress(g_adbwinusbapi_handle, "InstantiateWinUsbInterface"));
+    g_return = true;
+  }
+  else
+    g_return = false;
+
+ret:
+  return g_return;
+}
diff --git a/host/windows/usb/api/adb_api.cpp b/host/windows/usb/api/adb_api.cpp
index e58bcf17a..59d6ae8e6 100644
--- a/host/windows/usb/api/adb_api.cpp
+++ b/host/windows/usb/api/adb_api.cpp
@@ -1,533 +1,543 @@
-/*
- * Copyright (C) 2006 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-/** \file
-  This file consists of implementation of rotines that are exported
-  from this DLL.
-*/
-
-#include "stdafx.h"
-#include "adb_api.h"
-#include "adb_object_handle.h"
-#include "adb_interface_enum.h"
-#include "adb_interface.h"
-#include "adb_legacy_interface.h"
-#include "adb_endpoint_object.h"
-#include "adb_io_completion.h"
-#include "adb_helper_routines.h"
-#include "adb_winusb_api.h"
-
-/** \brief Points to InstantiateWinUsbInterface exported from AdbWinUsbApi.dll.
-
-  This variable is initialized with the actual address in DllMain routine for
-  this DLL on DLL_PROCESS_ATTACH event.
-  @see PFN_INSTWINUSBINTERFACE for more information.
-*/
-PFN_INSTWINUSBINTERFACE InstantiateWinUsbInterface = NULL;
-
-ADBAPIHANDLE __cdecl AdbEnumInterfaces(GUID class_id,
-                               bool exclude_not_present,
-                               bool exclude_removed,
-                               bool active_only) {
-  AdbInterfaceEnumObject* enum_obj = NULL;
-  ADBAPIHANDLE ret = NULL;
-
-  try {
-    // Instantiate and initialize enum object
-    enum_obj = new AdbInterfaceEnumObject();
-
-    if (enum_obj->InitializeEnum(class_id,
-                                 exclude_not_present,
-                                 exclude_removed,
-                                 active_only)) {
-      // After successful initialization we can create handle.
-      ret = enum_obj->CreateHandle();
-    }
-  } catch (...) {
-    SetLastError(ERROR_OUTOFMEMORY);
-  }
-
-  if (NULL != enum_obj)
-    enum_obj->Release();
-
-  return ret;
-}
-
-bool __cdecl AdbNextInterface(ADBAPIHANDLE adb_handle,
-                      AdbInterfaceInfo* info,
-                      unsigned long* size) {
-  if (NULL == size) {
-    SetLastError(ERROR_INVALID_PARAMETER);
-    return false;
-  }
-
-  // Lookup AdbInterfaceEnumObject object for the handle
-  AdbInterfaceEnumObject* adb_ienum_object =
-    LookupObject<AdbInterfaceEnumObject>(adb_handle);
-  if (NULL == adb_ienum_object)
-    return false;
-
-  // Everything is verified. Pass it down to the object
-  bool ret = adb_ienum_object->Next(info, size);
-
-  adb_ienum_object->Release();
-
-  return ret;
-}
-
-bool __cdecl AdbResetInterfaceEnum(ADBAPIHANDLE adb_handle) {
-  // Lookup AdbInterfaceEnumObject object for the handle
-  AdbInterfaceEnumObject* adb_ienum_object =
-    LookupObject<AdbInterfaceEnumObject>(adb_handle);
-  if (NULL == adb_ienum_object)
-    return false;
-
-  // Everything is verified. Pass it down to the object
-  bool ret = adb_ienum_object->Reset();
-
-  adb_ienum_object->Release();
-
-  return ret;
-}
-
-ADBAPIHANDLE __cdecl AdbCreateInterfaceByName(
-    const wchar_t* interface_name) {
-  AdbInterfaceObject* obj = NULL;
-  ADBAPIHANDLE ret = NULL;
-
-  try {
-    // Instantiate interface object, depending on the USB driver type.
-    if (IsLegacyInterface(interface_name)) {
-      // We have legacy USB driver underneath us.
-      obj = new AdbLegacyInterfaceObject(interface_name);
-    } else {
-      // We have WinUsb driver underneath us. Make sure that AdbWinUsbApi.dll
-      // is loaded and its InstantiateWinUsbInterface routine address has
-      // been cached.
-      if (NULL != InstantiateWinUsbInterface) {
-        obj = InstantiateWinUsbInterface(interface_name);
-        if (NULL == obj) {
-          return NULL;
-        }
-      } else {
-        return NULL;
-      }
-    }
-
-    // Create handle for it
-    ret = obj->CreateHandle();
-  } catch (...) {
-    SetLastError(ERROR_OUTOFMEMORY);
-  }
-
-  if (NULL != obj)
-    obj->Release();
-
-  return ret;
-}
-
-ADBAPIHANDLE __cdecl AdbCreateInterface(GUID class_id,
-                                unsigned short vendor_id,
-                                unsigned short product_id,
-                                unsigned char interface_id) {
-  // Enumerate all active interfaces for the given class
-  AdbEnumInterfaceArray interfaces;
-
-  if (!EnumerateDeviceInterfaces(class_id,
-                                 DIGCF_DEVICEINTERFACE | DIGCF_PRESENT,
-                                 true,
-                                 true,
-                                 &interfaces)) {
-    return NULL;
-  }
-
-  if (interfaces.empty()) {
-    SetLastError(ERROR_DEVICE_NOT_AVAILABLE);
-    return NULL;
-  }
-
-  // Now iterate over active interfaces looking for the name match.
-  // The name is formatted as such:
-  // "\\\\?\\usb#vid_xxxx&pid_xxxx&mi_xx#123456789abcdef#{XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX}"
-  // where
-  //    vid_xxxx is for the vendor id (xxxx are hex for the given vendor id),
-  //    pid_xxxx is for the product id (xxxx are hex for the given product id)
-  //    mi_xx is for the interface id  (xx are hex for the given interface id)
-  // EnumerateDeviceInterfaces will guarantee that returned interface names
-  // will have our class id at the end of the name (those last XXXes in the
-  // format). So, we only need to match the beginning of the name
-  wchar_t match_name[64];
-  if (0xFF == interface_id) {
-    // No interface id for the name.
-    swprintf(match_name, L"\\\\?\\usb#vid_%04x&pid_%04x#",
-             vendor_id, product_id);
-  } else {
-    // With interface id for the name.
-    swprintf(match_name, L"\\\\?\\usb#vid_%04x&pid_%04x&mi_%02x#",
-             vendor_id, product_id, interface_id);
-  }
-  size_t match_len = wcslen(match_name);
-
-  for (AdbEnumInterfaceArray::iterator it = interfaces.begin();
-       it != interfaces.end(); it++) {
-    const AdbInstanceEnumEntry& next_interface = *it;
-    if (0 == _wcsnicmp(match_name,
-                      next_interface.device_name().c_str(),
-                      match_len)) {
-      // Found requested interface among active interfaces.
-      return AdbCreateInterfaceByName(next_interface.device_name().c_str());
-    }
-  }
-
-  SetLastError(ERROR_DEVICE_NOT_AVAILABLE);
-  return NULL;
-}
-
-bool __cdecl AdbGetInterfaceName(ADBAPIHANDLE adb_interface,
-                         void* buffer,
-                         unsigned long* buffer_char_size,
-                         bool ansi) {
-  // Lookup interface object for the handle
-  AdbInterfaceObject* adb_object =
-    LookupObject<AdbInterfaceObject>(adb_interface);
-
-  if (NULL != adb_object) {
-    // Dispatch call to the found object
-    bool ret = adb_object->GetInterfaceName(buffer, buffer_char_size, ansi);
-    adb_object->Release();
-    return ret;
-  } else {
-    SetLastError(ERROR_INVALID_HANDLE);
-    return false;
-  }
-}
-
-bool __cdecl AdbGetSerialNumber(ADBAPIHANDLE adb_interface,
-                        void* buffer,
-                        unsigned long* buffer_char_size,
-                        bool ansi) {
-  // Lookup interface object for the handle
-  AdbInterfaceObject* adb_object =
-    LookupObject<AdbInterfaceObject>(adb_interface);
-
-  if (NULL != adb_object) {
-    // Dispatch call to the found object
-    bool ret = adb_object->GetSerialNumber(buffer, buffer_char_size, ansi);
-    adb_object->Release();
-    return ret;
-  } else {
-    SetLastError(ERROR_INVALID_HANDLE);
-    return false;
-  }
-}
-
-bool __cdecl AdbGetUsbDeviceDescriptor(ADBAPIHANDLE adb_interface,
-                               USB_DEVICE_DESCRIPTOR* desc) {
-  // Lookup interface object for the handle
-  AdbInterfaceObject* adb_object =
-    LookupObject<AdbInterfaceObject>(adb_interface);
-
-  if (NULL != adb_object) {
-    // Dispatch close to the found object
-    bool ret = adb_object->GetUsbDeviceDescriptor(desc);
-    adb_object->Release();
-    return ret;
-  } else {
-    SetLastError(ERROR_INVALID_HANDLE);
-    return false;
-  }
-}
-
-bool __cdecl AdbGetUsbConfigurationDescriptor(ADBAPIHANDLE adb_interface,
-                                      USB_CONFIGURATION_DESCRIPTOR* desc) {
-  // Lookup interface object for the handle
-  AdbInterfaceObject* adb_object =
-    LookupObject<AdbInterfaceObject>(adb_interface);
-
-  if (NULL != adb_object) {
-    // Dispatch close to the found object
-    bool ret = adb_object->GetUsbConfigurationDescriptor(desc);
-    adb_object->Release();
-    return ret;
-  } else {
-    SetLastError(ERROR_INVALID_HANDLE);
-    return false;
-  }
-}
-
-bool __cdecl AdbGetUsbInterfaceDescriptor(ADBAPIHANDLE adb_interface,
-                                  USB_INTERFACE_DESCRIPTOR* desc) {
-  // Lookup interface object for the handle
-  AdbInterfaceObject* adb_object =
-    LookupObject<AdbInterfaceObject>(adb_interface);
-
-  if (NULL != adb_object) {
-    // Dispatch close to the found object
-    bool ret = adb_object->GetUsbInterfaceDescriptor(desc);
-    adb_object->Release();
-    return ret;
-  } else {
-    SetLastError(ERROR_INVALID_HANDLE);
-    return false;
-  }
-}
-
-bool __cdecl AdbGetEndpointInformation(ADBAPIHANDLE adb_interface,
-                               UCHAR endpoint_index,
-                               AdbEndpointInformation* info) {
-  // Lookup interface object for the handle
-  AdbInterfaceObject* adb_object =
-    LookupObject<AdbInterfaceObject>(adb_interface);
-
-  if (NULL != adb_object) {
-    // Dispatch close to the found object
-    bool ret = adb_object->GetEndpointInformation(endpoint_index, info);
-    adb_object->Release();
-    return ret;
-  } else {
-    SetLastError(ERROR_INVALID_HANDLE);
-    return false;
-  }
-}
-
-bool __cdecl AdbGetDefaultBulkReadEndpointInformation(ADBAPIHANDLE adb_interface,
-                                              AdbEndpointInformation* info) {
-  return AdbGetEndpointInformation(adb_interface,
-                                   ADB_QUERY_BULK_READ_ENDPOINT_INDEX,
-                                   info);
-}
-
-bool __cdecl AdbGetDefaultBulkWriteEndpointInformation(ADBAPIHANDLE adb_interface,
-                                               AdbEndpointInformation* info) {
-  return AdbGetEndpointInformation(adb_interface,
-                                   ADB_QUERY_BULK_WRITE_ENDPOINT_INDEX,
-                                   info);
-}
-
-ADBAPIHANDLE __cdecl AdbOpenEndpoint(ADBAPIHANDLE adb_interface,
-                             unsigned char endpoint_index,
-                             AdbOpenAccessType access_type,
-                             AdbOpenSharingMode sharing_mode) {
-  // Lookup interface object for the handle
-  AdbInterfaceObject* adb_object =
-    LookupObject<AdbInterfaceObject>(adb_interface);
-
-  if (NULL != adb_object) {
-    // Dispatch close to the found object
-    ADBAPIHANDLE ret =
-      adb_object->OpenEndpoint(endpoint_index, access_type, sharing_mode);
-    adb_object->Release();
-    return ret;
-  } else {
-    SetLastError(ERROR_INVALID_HANDLE);
-    return NULL;
-  }
-}
-
-ADBAPIHANDLE __cdecl AdbOpenDefaultBulkReadEndpoint(ADBAPIHANDLE adb_interface,
-                                            AdbOpenAccessType access_type,
-                                            AdbOpenSharingMode sharing_mode) {
-  return AdbOpenEndpoint(adb_interface,
-                         ADB_QUERY_BULK_READ_ENDPOINT_INDEX,
-                         access_type,
-                         sharing_mode);
-}
-
-ADBAPIHANDLE __cdecl AdbOpenDefaultBulkWriteEndpoint(ADBAPIHANDLE adb_interface,
-                                             AdbOpenAccessType access_type,
-                                             AdbOpenSharingMode sharing_mode) {
-  return AdbOpenEndpoint(adb_interface,
-                         ADB_QUERY_BULK_WRITE_ENDPOINT_INDEX,
-                         access_type,
-                         sharing_mode);
-}
-
-ADBAPIHANDLE __cdecl AdbGetEndpointInterface(ADBAPIHANDLE adb_endpoint) {
-  // Lookup endpoint object for the handle
-  AdbEndpointObject* adb_object =
-    LookupObject<AdbEndpointObject>(adb_endpoint);
-
-  if (NULL != adb_object) {
-    // Dispatch the call to the found object
-    ADBAPIHANDLE ret = adb_object->GetParentInterfaceHandle();
-    adb_object->Release();
-    return ret;
-  } else {
-    SetLastError(ERROR_INVALID_HANDLE);
-    return NULL;
-  }
-}
-
-bool __cdecl AdbQueryInformationEndpoint(ADBAPIHANDLE adb_endpoint,
-                                 AdbEndpointInformation* info) {
-  // Lookup endpoint object for the handle
-  AdbEndpointObject* adb_object =
-    LookupObject<AdbEndpointObject>(adb_endpoint);
-
-  if (NULL != adb_object) {
-    // Dispatch the call to the found object
-    bool ret = adb_object->GetEndpointInformation(info);
-    adb_object->Release();
-    return ret;
-  } else {
-    SetLastError(ERROR_INVALID_HANDLE);
-    return false;
-  }
-}
-
-ADBAPIHANDLE __cdecl AdbReadEndpointAsync(ADBAPIHANDLE adb_endpoint,
-                                  void* buffer,
-                                  unsigned long bytes_to_read,
-                                  unsigned long* bytes_read,
-                                  unsigned long time_out,
-                                  HANDLE event_handle) {
-  // Lookup endpoint object for the handle
-  AdbEndpointObject* adb_object =
-    LookupObject<AdbEndpointObject>(adb_endpoint);
-
-  if (NULL != adb_object) {
-    // Dispatch the call to the found object
-    ADBAPIHANDLE ret = adb_object->AsyncRead(buffer,
-                                             bytes_to_read,
-                                             bytes_read,
-                                             event_handle,
-                                             time_out);
-    adb_object->Release();
-    return ret;
-  } else {
-    SetLastError(ERROR_INVALID_HANDLE);
-    return NULL;
-  }
-}
-
-ADBAPIHANDLE __cdecl AdbWriteEndpointAsync(ADBAPIHANDLE adb_endpoint,
-                                   void* buffer,
-                                   unsigned long bytes_to_write,
-                                   unsigned long* bytes_written,
-                                   unsigned long time_out,
-                                   HANDLE event_handle) {
-  // Lookup endpoint object for the handle
-  AdbEndpointObject* adb_object =
-    LookupObject<AdbEndpointObject>(adb_endpoint);
-
-  if (NULL != adb_object) {
-    // Dispatch the call to the found object
-    ADBAPIHANDLE ret = adb_object->AsyncWrite(buffer,
-                                              bytes_to_write,
-                                              bytes_written,
-                                              event_handle,
-                                              time_out);
-    adb_object->Release();
-    return ret;
-  } else {
-    SetLastError(ERROR_INVALID_HANDLE);
-    return false;
-  }
-}
-
-bool __cdecl AdbReadEndpointSync(ADBAPIHANDLE adb_endpoint,
-                         void* buffer,
-                         unsigned long bytes_to_read,
-                         unsigned long* bytes_read,
-                         unsigned long time_out) {
-  // Lookup endpoint object for the handle
-  AdbEndpointObject* adb_object =
-    LookupObject<AdbEndpointObject>(adb_endpoint);
-
-  if (NULL != adb_object) {
-    // Dispatch the call to the found object
-    bool ret =
-      adb_object->SyncRead(buffer, bytes_to_read, bytes_read, time_out);
-    adb_object->Release();
-    return ret;
-  } else {
-    SetLastError(ERROR_INVALID_HANDLE);
-    return NULL;
-  }
-}
-
-bool __cdecl AdbWriteEndpointSync(ADBAPIHANDLE adb_endpoint,
-                          void* buffer,
-                          unsigned long bytes_to_write,
-                          unsigned long* bytes_written,
-                          unsigned long time_out) {
-  // Lookup endpoint object for the handle
-  AdbEndpointObject* adb_object =
-    LookupObject<AdbEndpointObject>(adb_endpoint);
-
-  if (NULL != adb_object) {
-    // Dispatch the call to the found object
-    bool ret =
-      adb_object->SyncWrite(buffer, bytes_to_write, bytes_written, time_out);
-    adb_object->Release();
-    return ret;
-  } else {
-    SetLastError(ERROR_INVALID_HANDLE);
-    return false;
-  }
-}
-
-bool __cdecl AdbGetOvelappedIoResult(ADBAPIHANDLE adb_io_completion,
-                             LPOVERLAPPED overlapped,
-                             unsigned long* bytes_transferred,
-                             bool wait) {
-  // Lookup endpoint object for the handle
-  AdbIOCompletion* adb_object =
-    LookupObject<AdbIOCompletion>(adb_io_completion);
-
-  if (NULL != adb_object) {
-    // Dispatch the call to the found object
-    bool ret =
-      adb_object->GetOvelappedIoResult(overlapped, bytes_transferred, wait);
-    adb_object->Release();
-    return ret;
-  } else {
-    SetLastError(ERROR_INVALID_HANDLE);
-    return false;
-  }
-}
-
-bool __cdecl AdbHasOvelappedIoComplated(ADBAPIHANDLE adb_io_completion) {
-  // Lookup endpoint object for the handle
-  AdbIOCompletion* adb_object =
-    LookupObject<AdbIOCompletion>(adb_io_completion);
-
-  if (NULL != adb_object) {
-    // Dispatch the call to the found object
-    bool ret =
-      adb_object->IsCompleted();
-    adb_object->Release();
-    return ret;
-  } else {
-    SetLastError(ERROR_INVALID_HANDLE);
-    return true;
-  }
-}
-
-bool __cdecl AdbCloseHandle(ADBAPIHANDLE adb_handle) {
-  // Lookup object for the handle
-  AdbObjectHandle* adb_object = AdbObjectHandle::Lookup(adb_handle);
-
-  if (NULL != adb_object) {
-    // Dispatch close to the found object
-    bool ret = adb_object->CloseHandle();
-    adb_object->Release();
-    return ret;
-  } else {
-    SetLastError(ERROR_INVALID_HANDLE);
-    return false;
-  }
-}
+/*
+ * Copyright (C) 2006 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+/** \file
+  This file consists of implementation of rotines that are exported
+  from this DLL.
+*/
+
+#include "stdafx.h"
+#include "adb_api.h"
+#include "adb_object_handle.h"
+#include "adb_interface_enum.h"
+#include "adb_interface.h"
+#include "adb_legacy_interface.h"
+#include "adb_endpoint_object.h"
+#include "adb_io_completion.h"
+#include "adb_helper_routines.h"
+#include "adb_winusb_api.h"
+
+// defined in AdbWinApi.cpp
+extern bool AttachToAdbWinUsbApi();
+
+/** \brief Points to InstantiateWinUsbInterface exported from AdbWinUsbApi.dll.
+
+  This variable is initialized with the actual address in DllMain routine for
+  this DLL on DLL_PROCESS_ATTACH event.
+  @see PFN_INSTWINUSBINTERFACE for more information.
+*/
+PFN_INSTWINUSBINTERFACE InstantiateWinUsbInterface = NULL;
+
+ADBAPIHANDLE __cdecl AdbEnumInterfaces(GUID class_id,
+                               bool exclude_not_present,
+                               bool exclude_removed,
+                               bool active_only) {
+  AdbInterfaceEnumObject* enum_obj = NULL;
+  ADBAPIHANDLE ret = NULL;
+
+  try {
+    // Instantiate and initialize enum object
+    enum_obj = new AdbInterfaceEnumObject();
+
+    if (enum_obj->InitializeEnum(class_id,
+                                 exclude_not_present,
+                                 exclude_removed,
+                                 active_only)) {
+      // After successful initialization we can create handle.
+      ret = enum_obj->CreateHandle();
+    }
+  } catch (...) {
+    SetLastError(ERROR_OUTOFMEMORY);
+  }
+
+  if (NULL != enum_obj)
+    enum_obj->Release();
+
+  return ret;
+}
+
+bool __cdecl AdbNextInterface(ADBAPIHANDLE adb_handle,
+                      AdbInterfaceInfo* info,
+                      unsigned long* size) {
+  if (NULL == size) {
+    SetLastError(ERROR_INVALID_PARAMETER);
+    return false;
+  }
+
+  // Lookup AdbInterfaceEnumObject object for the handle
+  AdbInterfaceEnumObject* adb_ienum_object =
+    LookupObject<AdbInterfaceEnumObject>(adb_handle);
+  if (NULL == adb_ienum_object)
+    return false;
+
+  // Everything is verified. Pass it down to the object
+  bool ret = adb_ienum_object->Next(info, size);
+
+  adb_ienum_object->Release();
+
+  return ret;
+}
+
+bool __cdecl AdbResetInterfaceEnum(ADBAPIHANDLE adb_handle) {
+  // Lookup AdbInterfaceEnumObject object for the handle
+  AdbInterfaceEnumObject* adb_ienum_object =
+    LookupObject<AdbInterfaceEnumObject>(adb_handle);
+  if (NULL == adb_ienum_object)
+    return false;
+
+  // Everything is verified. Pass it down to the object
+  bool ret = adb_ienum_object->Reset();
+
+  adb_ienum_object->Release();
+
+  return ret;
+}
+
+ADBAPIHANDLE __cdecl AdbCreateInterfaceByName(
+    const wchar_t* interface_name) {
+  AdbInterfaceObject* obj = NULL;
+  ADBAPIHANDLE ret = NULL;
+
+  try {
+    // Instantiate interface object, depending on the USB driver type.
+    if (IsLegacyInterface(interface_name)) {
+      // We have legacy USB driver underneath us.
+      obj = new AdbLegacyInterfaceObject(interface_name);
+    } else {
+      // We have WinUsb driver underneath us. Make sure that AdbWinUsbApi.dll
+      // is loaded and its InstantiateWinUsbInterface routine address has
+      // been cached.
+      if (NULL != InstantiateWinUsbInterface) {
+        obj = InstantiateWinUsbInterface(interface_name);
+        if (NULL == obj) {
+          return NULL;
+        }
+      } else {
+        // HACK:
+        // since we aren't a dll (anymore!)
+        // we need to init somehow,
+        // do it now!
+        if (AttachToAdbWinUsbApi() && InstantiateWinUsbInterface != NULL)
+          return AdbCreateInterfaceByName(interface_name);
+        else
+          return NULL;
+      }
+    }
+
+    // Create handle for it
+    ret = obj->CreateHandle();
+  } catch (...) {
+    SetLastError(ERROR_OUTOFMEMORY);
+  }
+
+  if (NULL != obj)
+    obj->Release();
+
+  return ret;
+}
+
+ADBAPIHANDLE __cdecl AdbCreateInterface(GUID class_id,
+                                unsigned short vendor_id,
+                                unsigned short product_id,
+                                unsigned char interface_id) {
+  // Enumerate all active interfaces for the given class
+  AdbEnumInterfaceArray interfaces;
+
+  if (!EnumerateDeviceInterfaces(class_id,
+                                 DIGCF_DEVICEINTERFACE | DIGCF_PRESENT,
+                                 true,
+                                 true,
+                                 &interfaces)) {
+    return NULL;
+  }
+
+  if (interfaces.empty()) {
+    SetLastError(ERROR_DEVICE_NOT_AVAILABLE);
+    return NULL;
+  }
+
+  // Now iterate over active interfaces looking for the name match.
+  // The name is formatted as such:
+  // "\\\\?\\usb#vid_xxxx&pid_xxxx&mi_xx#123456789abcdef#{XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX}"
+  // where
+  //    vid_xxxx is for the vendor id (xxxx are hex for the given vendor id),
+  //    pid_xxxx is for the product id (xxxx are hex for the given product id)
+  //    mi_xx is for the interface id  (xx are hex for the given interface id)
+  // EnumerateDeviceInterfaces will guarantee that returned interface names
+  // will have our class id at the end of the name (those last XXXes in the
+  // format). So, we only need to match the beginning of the name
+  wchar_t match_name[64];
+  if (0xFF == interface_id) {
+    // No interface id for the name.
+    swprintf(match_name, L"\\\\?\\usb#vid_%04x&pid_%04x#",
+             vendor_id, product_id);
+  } else {
+    // With interface id for the name.
+    swprintf(match_name, L"\\\\?\\usb#vid_%04x&pid_%04x&mi_%02x#",
+             vendor_id, product_id, interface_id);
+  }
+  size_t match_len = wcslen(match_name);
+
+  for (AdbEnumInterfaceArray::iterator it = interfaces.begin();
+       it != interfaces.end(); it++) {
+    const AdbInstanceEnumEntry& next_interface = *it;
+    if (0 == _wcsnicmp(match_name,
+                      next_interface.device_name().c_str(),
+                      match_len)) {
+      // Found requested interface among active interfaces.
+      return AdbCreateInterfaceByName(next_interface.device_name().c_str());
+    }
+  }
+
+  SetLastError(ERROR_DEVICE_NOT_AVAILABLE);
+  return NULL;
+}
+
+bool __cdecl AdbGetInterfaceName(ADBAPIHANDLE adb_interface,
+                         void* buffer,
+                         unsigned long* buffer_char_size,
+                         bool ansi) {
+  // Lookup interface object for the handle
+  AdbInterfaceObject* adb_object =
+    LookupObject<AdbInterfaceObject>(adb_interface);
+
+  if (NULL != adb_object) {
+    // Dispatch call to the found object
+    bool ret = adb_object->GetInterfaceName(buffer, buffer_char_size, ansi);
+    adb_object->Release();
+    return ret;
+  } else {
+    SetLastError(ERROR_INVALID_HANDLE);
+    return false;
+  }
+}
+
+bool __cdecl AdbGetSerialNumber(ADBAPIHANDLE adb_interface,
+                        void* buffer,
+                        unsigned long* buffer_char_size,
+                        bool ansi) {
+  // Lookup interface object for the handle
+  AdbInterfaceObject* adb_object =
+    LookupObject<AdbInterfaceObject>(adb_interface);
+
+  if (NULL != adb_object) {
+    // Dispatch call to the found object
+    bool ret = adb_object->GetSerialNumber(buffer, buffer_char_size, ansi);
+    adb_object->Release();
+    return ret;
+  } else {
+    SetLastError(ERROR_INVALID_HANDLE);
+    return false;
+  }
+}
+
+bool __cdecl AdbGetUsbDeviceDescriptor(ADBAPIHANDLE adb_interface,
+                               USB_DEVICE_DESCRIPTOR* desc) {
+  // Lookup interface object for the handle
+  AdbInterfaceObject* adb_object =
+    LookupObject<AdbInterfaceObject>(adb_interface);
+
+  if (NULL != adb_object) {
+    // Dispatch close to the found object
+    bool ret = adb_object->GetUsbDeviceDescriptor(desc);
+    adb_object->Release();
+    return ret;
+  } else {
+    SetLastError(ERROR_INVALID_HANDLE);
+    return false;
+  }
+}
+
+bool __cdecl AdbGetUsbConfigurationDescriptor(ADBAPIHANDLE adb_interface,
+                                      USB_CONFIGURATION_DESCRIPTOR* desc) {
+  // Lookup interface object for the handle
+  AdbInterfaceObject* adb_object =
+    LookupObject<AdbInterfaceObject>(adb_interface);
+
+  if (NULL != adb_object) {
+    // Dispatch close to the found object
+    bool ret = adb_object->GetUsbConfigurationDescriptor(desc);
+    adb_object->Release();
+    return ret;
+  } else {
+    SetLastError(ERROR_INVALID_HANDLE);
+    return false;
+  }
+}
+
+bool __cdecl AdbGetUsbInterfaceDescriptor(ADBAPIHANDLE adb_interface,
+                                  USB_INTERFACE_DESCRIPTOR* desc) {
+  // Lookup interface object for the handle
+  AdbInterfaceObject* adb_object =
+    LookupObject<AdbInterfaceObject>(adb_interface);
+
+  if (NULL != adb_object) {
+    // Dispatch close to the found object
+    bool ret = adb_object->GetUsbInterfaceDescriptor(desc);
+    adb_object->Release();
+    return ret;
+  } else {
+    SetLastError(ERROR_INVALID_HANDLE);
+    return false;
+  }
+}
+
+bool __cdecl AdbGetEndpointInformation(ADBAPIHANDLE adb_interface,
+                               UCHAR endpoint_index,
+                               AdbEndpointInformation* info) {
+  // Lookup interface object for the handle
+  AdbInterfaceObject* adb_object =
+    LookupObject<AdbInterfaceObject>(adb_interface);
+
+  if (NULL != adb_object) {
+    // Dispatch close to the found object
+    bool ret = adb_object->GetEndpointInformation(endpoint_index, info);
+    adb_object->Release();
+    return ret;
+  } else {
+    SetLastError(ERROR_INVALID_HANDLE);
+    return false;
+  }
+}
+
+bool __cdecl AdbGetDefaultBulkReadEndpointInformation(ADBAPIHANDLE adb_interface,
+                                              AdbEndpointInformation* info) {
+  return AdbGetEndpointInformation(adb_interface,
+                                   ADB_QUERY_BULK_READ_ENDPOINT_INDEX,
+                                   info);
+}
+
+bool __cdecl AdbGetDefaultBulkWriteEndpointInformation(ADBAPIHANDLE adb_interface,
+                                               AdbEndpointInformation* info) {
+  return AdbGetEndpointInformation(adb_interface,
+                                   ADB_QUERY_BULK_WRITE_ENDPOINT_INDEX,
+                                   info);
+}
+
+ADBAPIHANDLE __cdecl AdbOpenEndpoint(ADBAPIHANDLE adb_interface,
+                             unsigned char endpoint_index,
+                             AdbOpenAccessType access_type,
+                             AdbOpenSharingMode sharing_mode) {
+  // Lookup interface object for the handle
+  AdbInterfaceObject* adb_object =
+    LookupObject<AdbInterfaceObject>(adb_interface);
+
+  if (NULL != adb_object) {
+    // Dispatch close to the found object
+    ADBAPIHANDLE ret =
+      adb_object->OpenEndpoint(endpoint_index, access_type, sharing_mode);
+    adb_object->Release();
+    return ret;
+  } else {
+    SetLastError(ERROR_INVALID_HANDLE);
+    return NULL;
+  }
+}
+
+ADBAPIHANDLE __cdecl AdbOpenDefaultBulkReadEndpoint(ADBAPIHANDLE adb_interface,
+                                            AdbOpenAccessType access_type,
+                                            AdbOpenSharingMode sharing_mode) {
+  return AdbOpenEndpoint(adb_interface,
+                         ADB_QUERY_BULK_READ_ENDPOINT_INDEX,
+                         access_type,
+                         sharing_mode);
+}
+
+ADBAPIHANDLE __cdecl AdbOpenDefaultBulkWriteEndpoint(ADBAPIHANDLE adb_interface,
+                                             AdbOpenAccessType access_type,
+                                             AdbOpenSharingMode sharing_mode) {
+  return AdbOpenEndpoint(adb_interface,
+                         ADB_QUERY_BULK_WRITE_ENDPOINT_INDEX,
+                         access_type,
+                         sharing_mode);
+}
+
+ADBAPIHANDLE __cdecl AdbGetEndpointInterface(ADBAPIHANDLE adb_endpoint) {
+  // Lookup endpoint object for the handle
+  AdbEndpointObject* adb_object =
+    LookupObject<AdbEndpointObject>(adb_endpoint);
+
+  if (NULL != adb_object) {
+    // Dispatch the call to the found object
+    ADBAPIHANDLE ret = adb_object->GetParentInterfaceHandle();
+    adb_object->Release();
+    return ret;
+  } else {
+    SetLastError(ERROR_INVALID_HANDLE);
+    return NULL;
+  }
+}
+
+bool __cdecl AdbQueryInformationEndpoint(ADBAPIHANDLE adb_endpoint,
+                                 AdbEndpointInformation* info) {
+  // Lookup endpoint object for the handle
+  AdbEndpointObject* adb_object =
+    LookupObject<AdbEndpointObject>(adb_endpoint);
+
+  if (NULL != adb_object) {
+    // Dispatch the call to the found object
+    bool ret = adb_object->GetEndpointInformation(info);
+    adb_object->Release();
+    return ret;
+  } else {
+    SetLastError(ERROR_INVALID_HANDLE);
+    return false;
+  }
+}
+
+ADBAPIHANDLE __cdecl AdbReadEndpointAsync(ADBAPIHANDLE adb_endpoint,
+                                  void* buffer,
+                                  unsigned long bytes_to_read,
+                                  unsigned long* bytes_read,
+                                  unsigned long time_out,
+                                  HANDLE event_handle) {
+  // Lookup endpoint object for the handle
+  AdbEndpointObject* adb_object =
+    LookupObject<AdbEndpointObject>(adb_endpoint);
+
+  if (NULL != adb_object) {
+    // Dispatch the call to the found object
+    ADBAPIHANDLE ret = adb_object->AsyncRead(buffer,
+                                             bytes_to_read,
+                                             bytes_read,
+                                             event_handle,
+                                             time_out);
+    adb_object->Release();
+    return ret;
+  } else {
+    SetLastError(ERROR_INVALID_HANDLE);
+    return NULL;
+  }
+}
+
+ADBAPIHANDLE __cdecl AdbWriteEndpointAsync(ADBAPIHANDLE adb_endpoint,
+                                   void* buffer,
+                                   unsigned long bytes_to_write,
+                                   unsigned long* bytes_written,
+                                   unsigned long time_out,
+                                   HANDLE event_handle) {
+  // Lookup endpoint object for the handle
+  AdbEndpointObject* adb_object =
+    LookupObject<AdbEndpointObject>(adb_endpoint);
+
+  if (NULL != adb_object) {
+    // Dispatch the call to the found object
+    ADBAPIHANDLE ret = adb_object->AsyncWrite(buffer,
+                                              bytes_to_write,
+                                              bytes_written,
+                                              event_handle,
+                                              time_out);
+    adb_object->Release();
+    return ret;
+  } else {
+    SetLastError(ERROR_INVALID_HANDLE);
+    return NULL;
+  }
+}
+
+bool __cdecl AdbReadEndpointSync(ADBAPIHANDLE adb_endpoint,
+                         void* buffer,
+                         unsigned long bytes_to_read,
+                         unsigned long* bytes_read,
+                         unsigned long time_out) {
+  // Lookup endpoint object for the handle
+  AdbEndpointObject* adb_object =
+    LookupObject<AdbEndpointObject>(adb_endpoint);
+
+  if (NULL != adb_object) {
+    // Dispatch the call to the found object
+    bool ret =
+      adb_object->SyncRead(buffer, bytes_to_read, bytes_read, time_out);
+    adb_object->Release();
+    return ret;
+  } else {
+    SetLastError(ERROR_INVALID_HANDLE);
+    return NULL;
+  }
+}
+
+bool __cdecl AdbWriteEndpointSync(ADBAPIHANDLE adb_endpoint,
+                          void* buffer,
+                          unsigned long bytes_to_write,
+                          unsigned long* bytes_written,
+                          unsigned long time_out) {
+  // Lookup endpoint object for the handle
+  AdbEndpointObject* adb_object =
+    LookupObject<AdbEndpointObject>(adb_endpoint);
+
+  if (NULL != adb_object) {
+    // Dispatch the call to the found object
+    bool ret =
+      adb_object->SyncWrite(buffer, bytes_to_write, bytes_written, time_out);
+    adb_object->Release();
+    return ret;
+  } else {
+    SetLastError(ERROR_INVALID_HANDLE);
+    return false;
+  }
+}
+
+bool __cdecl AdbGetOvelappedIoResult(ADBAPIHANDLE adb_io_completion,
+                             LPOVERLAPPED overlapped,
+                             unsigned long* bytes_transferred,
+                             bool wait) {
+  // Lookup endpoint object for the handle
+  AdbIOCompletion* adb_object =
+    LookupObject<AdbIOCompletion>(adb_io_completion);
+
+  if (NULL != adb_object) {
+    // Dispatch the call to the found object
+    bool ret =
+      adb_object->GetOvelappedIoResult(overlapped, bytes_transferred, wait);
+    adb_object->Release();
+    return ret;
+  } else {
+    SetLastError(ERROR_INVALID_HANDLE);
+    return false;
+  }
+}
+
+bool __cdecl AdbHasOvelappedIoComplated(ADBAPIHANDLE adb_io_completion) {
+  // Lookup endpoint object for the handle
+  AdbIOCompletion* adb_object =
+    LookupObject<AdbIOCompletion>(adb_io_completion);
+
+  if (NULL != adb_object) {
+    // Dispatch the call to the found object
+    bool ret =
+      adb_object->IsCompleted();
+    adb_object->Release();
+    return ret;
+  } else {
+    SetLastError(ERROR_INVALID_HANDLE);
+    return true;
+  }
+}
+
+bool __cdecl AdbCloseHandle(ADBAPIHANDLE adb_handle) {
+  // Lookup object for the handle
+  AdbObjectHandle* adb_object = AdbObjectHandle::Lookup(adb_handle);
+
+  if (NULL != adb_object) {
+    // Dispatch close to the found object
+    bool ret = adb_object->CloseHandle();
+    adb_object->Release();
+    return ret;
+  } else {
+    SetLastError(ERROR_INVALID_HANDLE);
+    return false;
+  }
+}
diff --git a/host/windows/usb/api/adb_api.h b/host/windows/usb/api/adb_api.h
index 9bd9274e9..fde2f93c7 100755
--- a/host/windows/usb/api/adb_api.h
+++ b/host/windows/usb/api/adb_api.h
@@ -1,603 +1,603 @@
-/*
- * Copyright (C) 2006 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-#ifndef ANDROID_USB_API_ADBWINAPI_H__
-#define ANDROID_USB_API_ADBWINAPI_H__
-
-#include <windows.h>
-#include <usb100.h>
-
-/** \file
-  This file consists of declarations of routines exported by the API as well
-  as types, structures, and constants definitions used in the API.
-*/
-
-// Enables compillation for "straight" C
-#ifdef __cplusplus
-  #define EXTERN_C    extern "C"
-#else
-  #define EXTERN_C    extern
-  typedef int bool;
-  #define true  1
-  #define false 0
-#endif
-
-/** \brief Enumerates ADB endpoint types.
-
-  This enum is taken from WDF_USB_PIPE_TYPE enum found in WDK.
-*/
-typedef enum _AdbEndpointType {
-  /// Unknown (invalid, or not initialized) endpoint type.
-  AdbEndpointTypeInvalid = 0,
-
-  /// Endpoint is device control pipe.
-  AdbEndpointTypeControl,
-
-  /// Endpoint is isochronous r/w pipe.
-  AdbEndpointTypeIsochronous,
-
-  /// Endpoint is a bulk r/w pipe.
-  AdbEndpointTypeBulk,
-
-  /// Endpoint is an interrupt r/w pipe.
-  AdbEndpointTypeInterrupt,
-} AdbEndpointType;
-
-/** \brief Endpoint desriptor.
-
-  This structure is based on WDF_USB_PIPE_INFORMATION structure found in WDK.
-*/
-typedef struct _AdbEndpointInformation {
-  /// Maximum packet size this endpoint is capable of.
-  unsigned long max_packet_size;
-
-  /// Maximum size of one transfer which should be sent to the host controller.
-  unsigned long max_transfer_size;
-
-  /// ADB endpoint type.
-  AdbEndpointType endpoint_type;
-
-  /// Raw endpoint address on the device as described by its descriptor.
-  unsigned char endpoint_address;
-
-  /// Polling interval.
-  unsigned char polling_interval;
-
-  /// Which alternate setting this structure is relevant for.
-  unsigned char setting_index;
-} AdbEndpointInformation;
-
-/// Shortcut to default write bulk endpoint in zero-based endpoint index API.
-#define ADB_QUERY_BULK_WRITE_ENDPOINT_INDEX  0xFC
-
-/// Shortcut to default read bulk endpoint in zero-based endpoint index API.
-#define ADB_QUERY_BULK_READ_ENDPOINT_INDEX  0xFE
-
-// {F72FE0D4-CBCB-407d-8814-9ED673D0DD6B}
-/// Our USB class id that driver uses to register our device.
-#define ANDROID_USB_CLASS_ID \
-{0xf72fe0d4, 0xcbcb, 0x407d, {0x88, 0x14, 0x9e, 0xd6, 0x73, 0xd0, 0xdd, 0x6b}};
-
-// The following ifdef block is the standard way of creating macros which make
-// exporting  from a DLL simpler. All files within this DLL are compiled with
-// the ADBWIN_EXPORTS symbol defined on the command line. this symbol should
-// not be defined on any project that uses this DLL. This way any other project
-// whose source files include this file see ADBWIN_API functions as being
-// imported from a DLL, whereas this DLL sees symbols defined with this macro
-// as being exported.
-#ifdef ADBWIN_EXPORTS
-#define ADBWIN_API EXTERN_C __declspec(dllexport)
-#define ADBWIN_API_CLASS     __declspec(dllexport)
-#else
-#define ADBWIN_API EXTERN_C __declspec(dllimport)
-#define ADBWIN_API_CLASS     __declspec(dllimport)
-#endif
-
-/** \brief Handle to an API object.
-
-  To access USB interface and its components clients must first obtain a
-  handle to the required object. API Objects that are represented by a
-  handle are:
-  1. Interface enumerator that provides access to a list of interfaces that
-     match certain criterias that were specified when interface enumerator
-     has been created. This handle is created in AdbEnumInterfaces routine.
-  2. Interface that is the major object this API deals with. In Windows
-     model of the USB stack each USB device (that is physical device,
-     attached to a USB port) exposes one or more interfaces that become the
-     major entities through which that device gets accessed. Each of these
-     interfaces are represented as Windows Device Objects on the USB stack.
-     So, to this extent, at least as this API is concerned, terms "interface"
-     and "device" are interchangeable, since each interface is represented by
-     a device object on the Windows USB stack. This handle is created in
-     either AdbCreateInterface or AdbCreateInterfaceByName routines.
-  3. Endpoint object (also called a pipe) represents an endpoint on interface
-     through which all I/O operations are performed. This handle is created in
-     one of these routines: AdbOpenEndpoint, AdbOpenDefaultBulkReadEndpoint,
-     or AdbOpenDefaultBulkWriteEndpoint.
-  4. I/O completion object that tracks completion information of asynchronous
-     I/O performed on an endpoint. When an endpoint object gets opened through
-     this API it is opened for asynchronous (or overlapped) I/O. And each time
-     an asynchronous I/O is performed by this API an I/O completion object is
-     created to track the result of that I/O when it gets completed. Clients
-     of the API can then use a handle to I/O completion object to query for
-     the status and result of asynchronous I/O as well as wait for this I/O
-     completion. This handle is created in one of these routines:
-     AdbReadEndpointAsync, or AdbWriteEndpointAsync.
-  After object is no longer needed by the client, its handle must be closed
-  using AdbCloseHandle routine.
-*/
-typedef void* ADBAPIHANDLE;
-
-/** \brief Defines access type with which an I/O object (endpoint)
-  should be opened.
-*/
-typedef enum _AdbOpenAccessType {
-  /// Opens for read and write access.
-  AdbOpenAccessTypeReadWrite,
-
-  /// Opens for read only access.
-  AdbOpenAccessTypeRead,
-
-  /// Opens for write only access.
-  AdbOpenAccessTypeWrite,
-
-  /// Opens for querying information.
-  AdbOpenAccessTypeQueryInfo,
-} AdbOpenAccessType;
-
-/** \brief Defines sharing mode with which an I/O object (endpoint)
-  should be opened.
-*/
-typedef enum _AdbOpenSharingMode {
-  /// Shares read and write.
-  AdbOpenSharingModeReadWrite,
-
-  /// Shares only read.
-  AdbOpenSharingModeRead,
-
-  /// Shares only write.
-  AdbOpenSharingModeWrite,
-
-  /// Opens exclusive.
-  AdbOpenSharingModeExclusive,
-} AdbOpenSharingMode;
-
-/** \brief Provides information about an interface.
-*/
-typedef struct _AdbInterfaceInfo {
-  /// Inteface's class id (see SP_DEVICE_INTERFACE_DATA for details)
-  GUID          class_id;
-
-  /// Interface flags (see SP_DEVICE_INTERFACE_DATA for details)
-  unsigned long flags;
-
-  /// Device name for the interface (see SP_DEVICE_INTERFACE_DETAIL_DATA
-  /// for details)
-  wchar_t       device_name[1];
-} AdbInterfaceInfo;
-
-/** \brief Creates USB interface enumerator
-
-  This routine enumerates all USB interfaces that match provided class ID.
-  This routine uses SetupDiGetClassDevs SDK routine to enumerate devices that
-  match class ID and then SetupDiEnumDeviceInterfaces SDK routine is called
-  to enumerate interfaces on the devices.
-  @param[in] class_id Device class ID, assigned by the driver.
-  @param[in] exclude_not_present If true enumation will include only those
-         devices that are currently present.
-  @param[in] exclude_removed If true interfaces with SPINT_REMOVED flag set
-         will be not included in the enumeration.
-  @param[in] active_only If true only active interfaces (with flag
-           SPINT_ACTIVE set) will be included in the enumeration.
-  @return Handle to the enumerator object or NULL on failure. If NULL is
-          returned GetLastError() provides extended error information.
-*/
-ADBWIN_API ADBAPIHANDLE __cdecl AdbEnumInterfaces(GUID class_id,
-                                          bool exclude_not_present,
-                                          bool exclude_removed,
-                                          bool active_only);
-
-/** \brief Gets next interface information
-
-  @param[in] adb_handle Handle to interface enumerator object obtained via
-         AdbEnumInterfaces call.
-  @param[out] info Upon successful completion will receive interface
-         information. Can be NULL. If it is NULL, upon return from this
-         routine size parameter will contain memory size required for the
-         next entry.
-  @param[in,out] size On the way in provides size of the memory buffer
-         addressed by info parameter. On the way out (only if buffer was not
-         big enough) will provide memory size required for the next entry.
-  @return true on success, false on error. If false is returned
-          GetLastError() provides extended error information.
-          ERROR_INSUFFICIENT_BUFFER indicates that buffer provided in info
-          parameter was not big enough and size parameter contains memory size
-          required for the next entry. ERROR_NO_MORE_ITEMS indicates that
-          enumeration is over and there are no more entries to return.
-*/
-ADBWIN_API bool __cdecl AdbNextInterface(ADBAPIHANDLE adb_handle,
-                                 AdbInterfaceInfo* info,
-                                 unsigned long* size);
-
-/** \brief Resets enumerator so next call to AdbNextInterface will start
-  from the beginning.
-
-  @param[in] adb_handle Handle to interface enumerator object obtained via
-         AdbEnumInterfaces call.
-  @return true on success, false on error. If false is returned GetLastError()
-          provides extended error information.
-*/
-ADBWIN_API bool __cdecl AdbResetInterfaceEnum(ADBAPIHANDLE adb_handle);
-
-/** \brief Creates USB interface object
-
-  This routine creates an object that represents a USB interface.
-  @param[in] interface_name Name of the interface.
-  @return Handle to the interface object or NULL on failure. If NULL is
-          returned GetLastError() provides extended error information.
-*/
-ADBWIN_API ADBAPIHANDLE __cdecl AdbCreateInterfaceByName(const wchar_t* interface_name);
-
-/** \brief Creates USB interface object based on vendor, product and
-  interface IDs.
-
-  This routine creates and object that represents a USB interface on our
-  device. It uses AdbCreateInterfaceByName to actually do the create.
-  @param[in] class_id Device class ID, assigned by the driver.
-  @param[in] vendor_id Device vendor ID
-  @param[in] product_id Device product ID
-  @param[in] interface_id Device interface ID. This parameter is optional.
-         Value 0xFF indicates that interface should be addressed by vendor
-         and product IDs only.
-  @return Handle to the interface object or NULL on failure. If NULL is
-          returned GetLastError() provides extended error information.
-*/
-ADBWIN_API ADBAPIHANDLE __cdecl AdbCreateInterface(GUID class_id,
-                                           unsigned short vendor_id,
-                                           unsigned short product_id,
-                                           unsigned char interface_id);
-
-/** \brief Gets interface name.
-
-  @param[in] adb_interface A handle to interface object created with 
-         AdbCreateInterface call.
-  @param[out] buffer Buffer for the name. Can be NULL in which case
-         buffer_char_size will contain number of characters required for
-         the name.
-  @param[in,out] buffer_char_size On the way in supplies size (in characters)
-         of the buffer. On the way out, if method failed and GetLastError
-         reports ERROR_INSUFFICIENT_BUFFER, will contain number of characters
-         required for the name.
-  @param[in] ansi If true the name will be returned as single character
-         string. Otherwise name will be returned as wide character string.
-  @return true on success, false on failure. If false is returned
-          GetLastError() provides extended error information.
-*/
-ADBWIN_API bool __cdecl AdbGetInterfaceName(ADBAPIHANDLE adb_interface,
-                                    void* buffer,
-                                    unsigned long* buffer_char_size,
-                                    bool ansi);
-
-/** \brief Gets serial number for interface's device.
-
-  @param[in] adb_interface A handle to interface object created with 
-         AdbCreateInterface call.
-  @param[out] buffer Buffer for the serail number string. Can be NULL in which
-         case buffer_char_size will contain number of characters required for
-         the string.
-  @param[in,out] buffer_char_size On the way in supplies size (in characters)
-         of the buffer. On the way out, if method failed and GetLastError
-         reports ERROR_INSUFFICIENT_BUFFER, will contain number of characters
-         required for the name.
-  @param[in] ansi If true the name will be returned as single character
-         string. Otherwise name will be returned as wide character string.
-  @return true on success, false on failure. If false is returned
-          GetLastError() provides extended error information.
-*/
-ADBWIN_API bool __cdecl AdbGetSerialNumber(ADBAPIHANDLE adb_interface,
-                                   void* buffer,
-                                   unsigned long* buffer_char_size,
-                                   bool ansi);
-
-/** \brief Gets device descriptor for the USB device associated with
-  the given interface.
-
-  @param[in] adb_interface A handle to interface object created with 
-         AdbCreateInterface call.
-  @param[out] desc Upon successful completion will have usb device
-         descriptor.
-  @return true on success, false on failure. If false is returned
-          GetLastError() provides extended error information.
-*/
-ADBWIN_API bool __cdecl AdbGetUsbDeviceDescriptor(ADBAPIHANDLE adb_interface,
-                                          USB_DEVICE_DESCRIPTOR* desc);
-
-/** \brief Gets descriptor for the selected USB device configuration.
-
-  @param[in] adb_interface A handle to interface object created with 
-         AdbCreateInterface call.
-  @param[out] desc Upon successful completion will have usb device
-         configuration descriptor.
-  @return true on success, false on failure. If false is returned
-          GetLastError() provides extended error information.
-*/
-ADBWIN_API bool __cdecl AdbGetUsbConfigurationDescriptor(
-                    ADBAPIHANDLE adb_interface,
-                    USB_CONFIGURATION_DESCRIPTOR* desc);
-
-/** \brief Gets descriptor for the given interface.
-
-  @param[in] adb_interface A handle to interface object created with 
-         AdbCreateInterface call.
-  @param[out] desc Upon successful completion will have usb device
-         configuration descriptor.
-  @return true on success, false on failure. If false is returned
-          GetLastError() provides extended error information.
-*/
-ADBWIN_API bool __cdecl AdbGetUsbInterfaceDescriptor(ADBAPIHANDLE adb_interface,
-                                             USB_INTERFACE_DESCRIPTOR* desc);
-
-/** \brief Gets information about an endpoint on the given interface.
-
-  @param[in] adb_interface A handle to interface object created with 
-         AdbCreateInterface call.
-  @param[in] endpoint_index Zero-based endpoint index. There are two
-         shortcuts for this parameter: ADB_QUERY_BULK_WRITE_ENDPOINT_INDEX
-         and ADB_QUERY_BULK_READ_ENDPOINT_INDEX that provide information
-         about bulk write and bulk read endpoints respectively.
-  @param[out] info Upon successful completion will have endpoint information.
-  @return true on success, false on failure. If false is returned
-          GetLastError() provides extended error information.
-*/
-ADBWIN_API bool __cdecl AdbGetEndpointInformation(ADBAPIHANDLE adb_interface,
-                                          unsigned char endpoint_index,
-                                          AdbEndpointInformation* info);
-
-/** \brief Gets information about default bulk read endpoint on the given
-  interface.
-
-  @param[in] adb_interface A handle to interface object created with 
-         AdbCreateInterface call.
-  @param[out] info Upon successful completion will have endpoint information.
-  @return true on success, false on failure. If false is returned
-          GetLastError() provides extended error information.
-*/
-ADBWIN_API bool __cdecl AdbGetDefaultBulkReadEndpointInformation(
-                    ADBAPIHANDLE adb_interface,
-                    AdbEndpointInformation* info);
-
-/** \brief Gets information about default bulk write endpoint on the given
-  interface.
-
-  @param[in] adb_interface A handle to interface object created with 
-         AdbCreateInterface call.
-  @param[out] info Upon successful completion will have endpoint information.
-  @return true on success, false on failure. If false is returned
-          GetLastError() provides extended error information.
-*/
-ADBWIN_API bool __cdecl AdbGetDefaultBulkWriteEndpointInformation(
-                    ADBAPIHANDLE adb_interface,
-                    AdbEndpointInformation* info);
-
-/** \brief Opens an endpoint on the given interface.
-
-  Endpoints are always opened for overlapped I/O.
-  @param[in] adb_interface A handle to interface object created with 
-         AdbCreateInterface call.
-  @param[in] endpoint_index Zero-based endpoint index. There are two
-         shortcuts for this parameter: ADB_QUERY_BULK_WRITE_ENDPOINT_INDEX
-         and ADB_QUERY_BULK_READ_ENDPOINT_INDEX that provide information
-         about bulk write and bulk read endpoints respectively.
-  @param[in] access_type Desired access type. In the current implementation
-         this parameter has no effect on the way endpoint is opened. It's
-         always read / write access.
-  @param[in] sharing_mode Desired share mode. In the current implementation
-         this parameter has no effect on the way endpoint is opened. It's
-         always shared for read / write.
-  @return Handle to the opened endpoint object or NULL on failure. If NULL is
-          returned GetLastError() provides extended error information.
-*/
-ADBWIN_API ADBAPIHANDLE __cdecl AdbOpenEndpoint(ADBAPIHANDLE adb_interface,
-                                        unsigned char endpoint_index,
-                                        AdbOpenAccessType access_type,
-                                        AdbOpenSharingMode sharing_mode);
-
-/** \brief Opens default bulk read endpoint on the given interface.
-
-  Endpoints are always opened for overlapped I/O.
-  @param[in] adb_interface A handle to interface object created with 
-         AdbCreateInterface call.
-  @param[in] access_type Desired access type. In the current implementation
-         this parameter has no effect on the way endpoint is opened. It's
-         always read / write access.
-  @param[in] sharing_mode Desired share mode. In the current implementation
-         this parameter has no effect on the way endpoint is opened. It's
-         always shared for read / write.
-  @return Handle to the opened endpoint object or NULL on failure. If NULL is
-          returned GetLastError() provides extended error information.
-*/
-ADBWIN_API ADBAPIHANDLE __cdecl AdbOpenDefaultBulkReadEndpoint(
-                            ADBAPIHANDLE adb_interface,
-                            AdbOpenAccessType access_type,
-                            AdbOpenSharingMode sharing_mode);
-
-/** \brief Opens default bulk write endpoint on the given interface.
-
-  Endpoints are always opened for overlapped I/O.
-  @param[in] adb_interface A handle to interface object created with 
-         AdbCreateInterface call.
-  @param[in] access_type Desired access type. In the current implementation
-         this parameter has no effect on the way endpoint is opened. It's
-         always read / write access.
-  @param[in] sharing_mode Desired share mode. In the current implementation
-         this parameter has no effect on the way endpoint is opened. It's
-         always shared for read / write.
-  @return Handle to the opened endpoint object or NULL on failure. If NULL is
-          returned GetLastError() provides extended error information.
-*/
-ADBWIN_API ADBAPIHANDLE __cdecl AdbOpenDefaultBulkWriteEndpoint(
-                            ADBAPIHANDLE adb_interface,
-                            AdbOpenAccessType access_type,
-                            AdbOpenSharingMode sharing_mode);
-
-/** \brief Gets handle to interface object for the given endpoint
-
-  @param[in] adb_endpoint A handle to opened endpoint object, obtained via one
-         of the AdbOpenXxxEndpoint calls.
-  @return Handle to the interface for this endpoint or NULL on failure. If NULL
-          is returned GetLastError() provides extended error information.
-*/
-ADBWIN_API ADBAPIHANDLE __cdecl AdbGetEndpointInterface(ADBAPIHANDLE adb_endpoint);
-
-/** \brief Gets information about the given endpoint.
-
-  @param[in] adb_endpoint A handle to opened endpoint object, obtained via one
-         of the AdbOpenXxxEndpoint calls.
-  @param[out] info Upon successful completion will have endpoint information.
-  @return true on success, false on failure. If false is returned
-          GetLastError() provides extended error information.
-*/
-ADBWIN_API bool __cdecl AdbQueryInformationEndpoint(ADBAPIHANDLE adb_endpoint,
-                                            AdbEndpointInformation* info);
-
-/** \brief Asynchronously reads from the given endpoint.
-
-  @param[in] adb_endpoint A handle to opened endpoint object, obtained via one
-         of the AdbOpenXxxEndpoint calls.
-  @param[out] buffer Pointer to the buffer that receives the data.
-  @param[in] bytes_to_read Number of bytes to be read.
-  @param[out] bytes_read Number of bytes read. Can be NULL.
-  @param[in] event_handle Event handle that should be signaled when async I/O
-         completes. Can be NULL. If it's not NULL this handle will be used to
-         initialize OVERLAPPED structure for this I/O.
-  @param[in] time_out A timeout (in milliseconds) required for this I/O to
-         complete. Zero value for this parameter means that there is no
-         timeout for this I/O.
-  @return A handle to IO completion object or NULL on failure. If NULL is
-          returned GetLastError() provides extended error information.
-*/
-ADBWIN_API ADBAPIHANDLE __cdecl AdbReadEndpointAsync(ADBAPIHANDLE adb_endpoint,
-                                             void* buffer,
-                                             unsigned long bytes_to_read,
-                                             unsigned long* bytes_read,
-                                             unsigned long time_out,
-                                             HANDLE event_handle);
-
-/** \brief Asynchronously writes to the given endpoint.
-
-  @param[in] adb_endpoint A handle to opened endpoint object, obtained via one
-         of the AdbOpenXxxEndpoint calls.
-  @param[in] buffer Pointer to the buffer containing the data to be written.
-  @param[in] bytes_to_write Number of bytes to be written.
-  @param[out] bytes_written Number of bytes written. Can be NULL.
-  @param[in] event_handle Event handle that should be signaled when async I/O
-         completes. Can be NULL. If it's not NULL this handle will be used to
-         initialize OVERLAPPED structure for this I/O.
-  @param[in] time_out A timeout (in milliseconds) required for this I/O to
-         complete. Zero value for this parameter means that there is no
-         timeout for this I/O.
-  @return A handle to IO completion object or NULL on failure. If NULL is
-          returned GetLastError() provides extended error information.
-*/
-ADBWIN_API ADBAPIHANDLE __cdecl AdbWriteEndpointAsync(ADBAPIHANDLE adb_endpoint,
-                                              void* buffer,
-                                              unsigned long bytes_to_write,
-                                              unsigned long* bytes_written,
-                                              unsigned long time_out,
-                                              HANDLE event_handle);
-
-/** \brief Synchronously reads from the given endpoint.
-
-  @param[in] adb_endpoint A handle to opened endpoint object, obtained via one
-         of the AdbOpenXxxEndpoint calls.
-  @param[out] buffer Pointer to the buffer that receives the data.
-  @param[in] bytes_to_read Number of bytes to be read.
-  @param[out] bytes_read Number of bytes read. Can be NULL.
-  @param[in] time_out A timeout (in milliseconds) required for this I/O to
-         complete. Zero value for this parameter means that there is no
-         timeout for this I/O.
-  @return true on success and false on failure. If false is
-          returned GetLastError() provides extended error information.
-*/
-ADBWIN_API bool __cdecl AdbReadEndpointSync(ADBAPIHANDLE adb_endpoint,
-                                    void* buffer,
-                                    unsigned long bytes_to_read,
-                                    unsigned long* bytes_read,
-                                    unsigned long time_out);
-
-/** \brief Synchronously writes to the given endpoint.
-
-  @param[in] adb_endpoint A handle to opened endpoint object, obtained via one
-         of the AdbOpenXxxEndpoint calls.
-  @param[in] buffer Pointer to the buffer containing the data to be written.
-  @param[in] bytes_to_write Number of bytes to be written.
-  @param[out] bytes_written Number of bytes written. Can be NULL.
-  @param[in] time_out A timeout (in milliseconds) required for this I/O to
-         complete. Zero value for this parameter means that there is no
-         timeout for this I/O.
-  @return true on success and false on failure. If false is
-          returned GetLastError() provides extended error information.
-*/
-ADBWIN_API bool __cdecl AdbWriteEndpointSync(ADBAPIHANDLE adb_endpoint,
-                                     void* buffer,
-                                     unsigned long bytes_to_write,
-                                     unsigned long* bytes_written,
-                                     unsigned long time_out);
-
-/** \brief Gets overlapped I/O result for async I/O performed on the
-  given endpoint.
-
-  @param[in] adb_io_completion A handle to an I/O completion object returned
-         from AdbRead/WriteAsync routines.
-  @param[out] ovl_data Buffer for the copy of this object's OVERLAPPED
-         structure. Can be NULL.
-  @param[out] bytes_transferred Pointer to a variable that receives the
-         number of bytes that were actually transferred by a read or write
-         operation. See SDK doc on GetOvelappedResult for more information.
-         Unlike regular GetOvelappedResult call this parameter can be NULL.
-  @param[in] wait If this parameter is true, the method does not return
-         until the operation has been completed. If this parameter is false
-         and the operation is still pending, the method returns false and
-         the GetLastError function returns ERROR_IO_INCOMPLETE.
-  @return true if I/O has been completed or false on failure or if request
-         is not yet completed. If false is returned GetLastError() provides
-         extended error information. If GetLastError returns
-         ERROR_IO_INCOMPLETE it means that I/O is not yet completed.
-*/
-ADBWIN_API bool __cdecl AdbGetOvelappedIoResult(ADBAPIHANDLE adb_io_completion,
-                                        LPOVERLAPPED overlapped,
-                                        unsigned long* bytes_transferred,
-                                        bool wait);
-
-/** \brief Checks if overlapped I/O has been completed.
-
-  @param[in] adb_io_completion A handle to an I/O completion object returned
-         from AdbRead/WriteAsync routines.
-  @return true if I/O has been completed or false if it's still
-          incomplete. Regardless of the returned value, caller should
-          check GetLastError to validate that handle was OK.
-*/
-ADBWIN_API bool __cdecl AdbHasOvelappedIoComplated(ADBAPIHANDLE adb_io_completion);
-
-/** \brief Closes handle previously opened with one of the API calls
-
-  @param[in] adb_handle ADB handle previously opened with one of the API calls
-  @return true on success or false on failure. If false is returned
-          GetLastError() provides extended error information.
-*/
-ADBWIN_API bool __cdecl AdbCloseHandle(ADBAPIHANDLE adb_handle);
-
-#endif  // ANDROID_USB_API_ADBWINAPI_H__
+/*
+ * Copyright (C) 2006 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#ifndef ANDROID_USB_API_ADBWINAPI_H__
+#define ANDROID_USB_API_ADBWINAPI_H__
+
+#include <windows.h>
+#include <usb100.h>
+
+/** \file
+  This file consists of declarations of routines exported by the API as well
+  as types, structures, and constants definitions used in the API.
+*/
+
+// Enables compillation for "straight" C
+#ifdef __cplusplus
+  #define EXTERN_C    extern "C"
+#else
+  #define EXTERN_C    extern
+  typedef int bool;
+  #define true  1
+  #define false 0
+#endif
+
+/** \brief Enumerates ADB endpoint types.
+
+  This enum is taken from WDF_USB_PIPE_TYPE enum found in WDK.
+*/
+typedef enum _AdbEndpointType {
+  /// Unknown (invalid, or not initialized) endpoint type.
+  AdbEndpointTypeInvalid = 0,
+
+  /// Endpoint is device control pipe.
+  AdbEndpointTypeControl,
+
+  /// Endpoint is isochronous r/w pipe.
+  AdbEndpointTypeIsochronous,
+
+  /// Endpoint is a bulk r/w pipe.
+  AdbEndpointTypeBulk,
+
+  /// Endpoint is an interrupt r/w pipe.
+  AdbEndpointTypeInterrupt,
+} AdbEndpointType;
+
+/** \brief Endpoint desriptor.
+
+  This structure is based on WDF_USB_PIPE_INFORMATION structure found in WDK.
+*/
+typedef struct _AdbEndpointInformation {
+  /// Maximum packet size this endpoint is capable of.
+  unsigned long max_packet_size;
+
+  /// Maximum size of one transfer which should be sent to the host controller.
+  unsigned long max_transfer_size;
+
+  /// ADB endpoint type.
+  AdbEndpointType endpoint_type;
+
+  /// Raw endpoint address on the device as described by its descriptor.
+  unsigned char endpoint_address;
+
+  /// Polling interval.
+  unsigned char polling_interval;
+
+  /// Which alternate setting this structure is relevant for.
+  unsigned char setting_index;
+} AdbEndpointInformation;
+
+/// Shortcut to default write bulk endpoint in zero-based endpoint index API.
+#define ADB_QUERY_BULK_WRITE_ENDPOINT_INDEX  0xFC
+
+/// Shortcut to default read bulk endpoint in zero-based endpoint index API.
+#define ADB_QUERY_BULK_READ_ENDPOINT_INDEX  0xFE
+
+// {F72FE0D4-CBCB-407d-8814-9ED673D0DD6B}
+/// Our USB class id that driver uses to register our device.
+#define ANDROID_USB_CLASS_ID \
+{0xf72fe0d4, 0xcbcb, 0x407d, {0x88, 0x14, 0x9e, 0xd6, 0x73, 0xd0, 0xdd, 0x6b}};
+
+// The following ifdef block is the standard way of creating macros which make
+// exporting  from a DLL simpler. All files within this DLL are compiled with
+// the ADBWIN_EXPORTS symbol defined on the command line. this symbol should
+// not be defined on any project that uses this DLL. This way any other project
+// whose source files include this file see ADBWIN_API functions as being
+// imported from a DLL, whereas this DLL sees symbols defined with this macro
+// as being exported.
+#ifdef ADBWIN_EXPORTS
+#define ADBWIN_API EXTERN_C __declspec(dllexport)
+#define ADBWIN_API_CLASS     __declspec(dllexport)
+#else
+#define ADBWIN_API EXTERN_C
+#define ADBWIN_API_CLASS
+#endif
+
+/** \brief Handle to an API object.
+
+  To access USB interface and its components clients must first obtain a
+  handle to the required object. API Objects that are represented by a
+  handle are:
+  1. Interface enumerator that provides access to a list of interfaces that
+     match certain criterias that were specified when interface enumerator
+     has been created. This handle is created in AdbEnumInterfaces routine.
+  2. Interface that is the major object this API deals with. In Windows
+     model of the USB stack each USB device (that is physical device,
+     attached to a USB port) exposes one or more interfaces that become the
+     major entities through which that device gets accessed. Each of these
+     interfaces are represented as Windows Device Objects on the USB stack.
+     So, to this extent, at least as this API is concerned, terms "interface"
+     and "device" are interchangeable, since each interface is represented by
+     a device object on the Windows USB stack. This handle is created in
+     either AdbCreateInterface or AdbCreateInterfaceByName routines.
+  3. Endpoint object (also called a pipe) represents an endpoint on interface
+     through which all I/O operations are performed. This handle is created in
+     one of these routines: AdbOpenEndpoint, AdbOpenDefaultBulkReadEndpoint,
+     or AdbOpenDefaultBulkWriteEndpoint.
+  4. I/O completion object that tracks completion information of asynchronous
+     I/O performed on an endpoint. When an endpoint object gets opened through
+     this API it is opened for asynchronous (or overlapped) I/O. And each time
+     an asynchronous I/O is performed by this API an I/O completion object is
+     created to track the result of that I/O when it gets completed. Clients
+     of the API can then use a handle to I/O completion object to query for
+     the status and result of asynchronous I/O as well as wait for this I/O
+     completion. This handle is created in one of these routines:
+     AdbReadEndpointAsync, or AdbWriteEndpointAsync.
+  After object is no longer needed by the client, its handle must be closed
+  using AdbCloseHandle routine.
+*/
+typedef void* ADBAPIHANDLE;
+
+/** \brief Defines access type with which an I/O object (endpoint)
+  should be opened.
+*/
+typedef enum _AdbOpenAccessType {
+  /// Opens for read and write access.
+  AdbOpenAccessTypeReadWrite,
+
+  /// Opens for read only access.
+  AdbOpenAccessTypeRead,
+
+  /// Opens for write only access.
+  AdbOpenAccessTypeWrite,
+
+  /// Opens for querying information.
+  AdbOpenAccessTypeQueryInfo,
+} AdbOpenAccessType;
+
+/** \brief Defines sharing mode with which an I/O object (endpoint)
+  should be opened.
+*/
+typedef enum _AdbOpenSharingMode {
+  /// Shares read and write.
+  AdbOpenSharingModeReadWrite,
+
+  /// Shares only read.
+  AdbOpenSharingModeRead,
+
+  /// Shares only write.
+  AdbOpenSharingModeWrite,
+
+  /// Opens exclusive.
+  AdbOpenSharingModeExclusive,
+} AdbOpenSharingMode;
+
+/** \brief Provides information about an interface.
+*/
+typedef struct _AdbInterfaceInfo {
+  /// Inteface's class id (see SP_DEVICE_INTERFACE_DATA for details)
+  GUID          class_id;
+
+  /// Interface flags (see SP_DEVICE_INTERFACE_DATA for details)
+  unsigned long flags;
+
+  /// Device name for the interface (see SP_DEVICE_INTERFACE_DETAIL_DATA
+  /// for details)
+  wchar_t       device_name[1];
+} AdbInterfaceInfo;
+
+/** \brief Creates USB interface enumerator
+
+  This routine enumerates all USB interfaces that match provided class ID.
+  This routine uses SetupDiGetClassDevs SDK routine to enumerate devices that
+  match class ID and then SetupDiEnumDeviceInterfaces SDK routine is called
+  to enumerate interfaces on the devices.
+  @param[in] class_id Device class ID, assigned by the driver.
+  @param[in] exclude_not_present If true enumation will include only those
+         devices that are currently present.
+  @param[in] exclude_removed If true interfaces with SPINT_REMOVED flag set
+         will be not included in the enumeration.
+  @param[in] active_only If true only active interfaces (with flag
+           SPINT_ACTIVE set) will be included in the enumeration.
+  @return Handle to the enumerator object or NULL on failure. If NULL is
+          returned GetLastError() provides extended error information.
+*/
+ADBWIN_API ADBAPIHANDLE __cdecl AdbEnumInterfaces(GUID class_id,
+                                          bool exclude_not_present,
+                                          bool exclude_removed,
+                                          bool active_only);
+
+/** \brief Gets next interface information
+
+  @param[in] adb_handle Handle to interface enumerator object obtained via
+         AdbEnumInterfaces call.
+  @param[out] info Upon successful completion will receive interface
+         information. Can be NULL. If it is NULL, upon return from this
+         routine size parameter will contain memory size required for the
+         next entry.
+  @param[in,out] size On the way in provides size of the memory buffer
+         addressed by info parameter. On the way out (only if buffer was not
+         big enough) will provide memory size required for the next entry.
+  @return true on success, false on error. If false is returned
+          GetLastError() provides extended error information.
+          ERROR_INSUFFICIENT_BUFFER indicates that buffer provided in info
+          parameter was not big enough and size parameter contains memory size
+          required for the next entry. ERROR_NO_MORE_ITEMS indicates that
+          enumeration is over and there are no more entries to return.
+*/
+ADBWIN_API bool __cdecl AdbNextInterface(ADBAPIHANDLE adb_handle,
+                                 AdbInterfaceInfo* info,
+                                 unsigned long* size);
+
+/** \brief Resets enumerator so next call to AdbNextInterface will start
+  from the beginning.
+
+  @param[in] adb_handle Handle to interface enumerator object obtained via
+         AdbEnumInterfaces call.
+  @return true on success, false on error. If false is returned GetLastError()
+          provides extended error information.
+*/
+ADBWIN_API bool __cdecl AdbResetInterfaceEnum(ADBAPIHANDLE adb_handle);
+
+/** \brief Creates USB interface object
+
+  This routine creates an object that represents a USB interface.
+  @param[in] interface_name Name of the interface.
+  @return Handle to the interface object or NULL on failure. If NULL is
+          returned GetLastError() provides extended error information.
+*/
+ADBWIN_API ADBAPIHANDLE __cdecl AdbCreateInterfaceByName(const wchar_t* interface_name);
+
+/** \brief Creates USB interface object based on vendor, product and
+  interface IDs.
+
+  This routine creates and object that represents a USB interface on our
+  device. It uses AdbCreateInterfaceByName to actually do the create.
+  @param[in] class_id Device class ID, assigned by the driver.
+  @param[in] vendor_id Device vendor ID
+  @param[in] product_id Device product ID
+  @param[in] interface_id Device interface ID. This parameter is optional.
+         Value 0xFF indicates that interface should be addressed by vendor
+         and product IDs only.
+  @return Handle to the interface object or NULL on failure. If NULL is
+          returned GetLastError() provides extended error information.
+*/
+ADBWIN_API ADBAPIHANDLE __cdecl AdbCreateInterface(GUID class_id,
+                                           unsigned short vendor_id,
+                                           unsigned short product_id,
+                                           unsigned char interface_id);
+
+/** \brief Gets interface name.
+
+  @param[in] adb_interface A handle to interface object created with 
+         AdbCreateInterface call.
+  @param[out] buffer Buffer for the name. Can be NULL in which case
+         buffer_char_size will contain number of characters required for
+         the name.
+  @param[in,out] buffer_char_size On the way in supplies size (in characters)
+         of the buffer. On the way out, if method failed and GetLastError
+         reports ERROR_INSUFFICIENT_BUFFER, will contain number of characters
+         required for the name.
+  @param[in] ansi If true the name will be returned as single character
+         string. Otherwise name will be returned as wide character string.
+  @return true on success, false on failure. If false is returned
+          GetLastError() provides extended error information.
+*/
+ADBWIN_API bool __cdecl AdbGetInterfaceName(ADBAPIHANDLE adb_interface,
+                                    void* buffer,
+                                    unsigned long* buffer_char_size,
+                                    bool ansi);
+
+/** \brief Gets serial number for interface's device.
+
+  @param[in] adb_interface A handle to interface object created with 
+         AdbCreateInterface call.
+  @param[out] buffer Buffer for the serail number string. Can be NULL in which
+         case buffer_char_size will contain number of characters required for
+         the string.
+  @param[in,out] buffer_char_size On the way in supplies size (in characters)
+         of the buffer. On the way out, if method failed and GetLastError
+         reports ERROR_INSUFFICIENT_BUFFER, will contain number of characters
+         required for the name.
+  @param[in] ansi If true the name will be returned as single character
+         string. Otherwise name will be returned as wide character string.
+  @return true on success, false on failure. If false is returned
+          GetLastError() provides extended error information.
+*/
+ADBWIN_API bool __cdecl AdbGetSerialNumber(ADBAPIHANDLE adb_interface,
+                                   void* buffer,
+                                   unsigned long* buffer_char_size,
+                                   bool ansi);
+
+/** \brief Gets device descriptor for the USB device associated with
+  the given interface.
+
+  @param[in] adb_interface A handle to interface object created with 
+         AdbCreateInterface call.
+  @param[out] desc Upon successful completion will have usb device
+         descriptor.
+  @return true on success, false on failure. If false is returned
+          GetLastError() provides extended error information.
+*/
+ADBWIN_API bool __cdecl AdbGetUsbDeviceDescriptor(ADBAPIHANDLE adb_interface,
+                                          USB_DEVICE_DESCRIPTOR* desc);
+
+/** \brief Gets descriptor for the selected USB device configuration.
+
+  @param[in] adb_interface A handle to interface object created with 
+         AdbCreateInterface call.
+  @param[out] desc Upon successful completion will have usb device
+         configuration descriptor.
+  @return true on success, false on failure. If false is returned
+          GetLastError() provides extended error information.
+*/
+ADBWIN_API bool __cdecl AdbGetUsbConfigurationDescriptor(
+                    ADBAPIHANDLE adb_interface,
+                    USB_CONFIGURATION_DESCRIPTOR* desc);
+
+/** \brief Gets descriptor for the given interface.
+
+  @param[in] adb_interface A handle to interface object created with 
+         AdbCreateInterface call.
+  @param[out] desc Upon successful completion will have usb device
+         configuration descriptor.
+  @return true on success, false on failure. If false is returned
+          GetLastError() provides extended error information.
+*/
+ADBWIN_API bool __cdecl AdbGetUsbInterfaceDescriptor(ADBAPIHANDLE adb_interface,
+                                             USB_INTERFACE_DESCRIPTOR* desc);
+
+/** \brief Gets information about an endpoint on the given interface.
+
+  @param[in] adb_interface A handle to interface object created with 
+         AdbCreateInterface call.
+  @param[in] endpoint_index Zero-based endpoint index. There are two
+         shortcuts for this parameter: ADB_QUERY_BULK_WRITE_ENDPOINT_INDEX
+         and ADB_QUERY_BULK_READ_ENDPOINT_INDEX that provide information
+         about bulk write and bulk read endpoints respectively.
+  @param[out] info Upon successful completion will have endpoint information.
+  @return true on success, false on failure. If false is returned
+          GetLastError() provides extended error information.
+*/
+ADBWIN_API bool __cdecl AdbGetEndpointInformation(ADBAPIHANDLE adb_interface,
+                                          unsigned char endpoint_index,
+                                          AdbEndpointInformation* info);
+
+/** \brief Gets information about default bulk read endpoint on the given
+  interface.
+
+  @param[in] adb_interface A handle to interface object created with 
+         AdbCreateInterface call.
+  @param[out] info Upon successful completion will have endpoint information.
+  @return true on success, false on failure. If false is returned
+          GetLastError() provides extended error information.
+*/
+ADBWIN_API bool __cdecl AdbGetDefaultBulkReadEndpointInformation(
+                    ADBAPIHANDLE adb_interface,
+                    AdbEndpointInformation* info);
+
+/** \brief Gets information about default bulk write endpoint on the given
+  interface.
+
+  @param[in] adb_interface A handle to interface object created with 
+         AdbCreateInterface call.
+  @param[out] info Upon successful completion will have endpoint information.
+  @return true on success, false on failure. If false is returned
+          GetLastError() provides extended error information.
+*/
+ADBWIN_API bool __cdecl AdbGetDefaultBulkWriteEndpointInformation(
+                    ADBAPIHANDLE adb_interface,
+                    AdbEndpointInformation* info);
+
+/** \brief Opens an endpoint on the given interface.
+
+  Endpoints are always opened for overlapped I/O.
+  @param[in] adb_interface A handle to interface object created with 
+         AdbCreateInterface call.
+  @param[in] endpoint_index Zero-based endpoint index. There are two
+         shortcuts for this parameter: ADB_QUERY_BULK_WRITE_ENDPOINT_INDEX
+         and ADB_QUERY_BULK_READ_ENDPOINT_INDEX that provide information
+         about bulk write and bulk read endpoints respectively.
+  @param[in] access_type Desired access type. In the current implementation
+         this parameter has no effect on the way endpoint is opened. It's
+         always read / write access.
+  @param[in] sharing_mode Desired share mode. In the current implementation
+         this parameter has no effect on the way endpoint is opened. It's
+         always shared for read / write.
+  @return Handle to the opened endpoint object or NULL on failure. If NULL is
+          returned GetLastError() provides extended error information.
+*/
+ADBWIN_API ADBAPIHANDLE __cdecl AdbOpenEndpoint(ADBAPIHANDLE adb_interface,
+                                        unsigned char endpoint_index,
+                                        AdbOpenAccessType access_type,
+                                        AdbOpenSharingMode sharing_mode);
+
+/** \brief Opens default bulk read endpoint on the given interface.
+
+  Endpoints are always opened for overlapped I/O.
+  @param[in] adb_interface A handle to interface object created with 
+         AdbCreateInterface call.
+  @param[in] access_type Desired access type. In the current implementation
+         this parameter has no effect on the way endpoint is opened. It's
+         always read / write access.
+  @param[in] sharing_mode Desired share mode. In the current implementation
+         this parameter has no effect on the way endpoint is opened. It's
+         always shared for read / write.
+  @return Handle to the opened endpoint object or NULL on failure. If NULL is
+          returned GetLastError() provides extended error information.
+*/
+ADBWIN_API ADBAPIHANDLE __cdecl AdbOpenDefaultBulkReadEndpoint(
+                            ADBAPIHANDLE adb_interface,
+                            AdbOpenAccessType access_type,
+                            AdbOpenSharingMode sharing_mode);
+
+/** \brief Opens default bulk write endpoint on the given interface.
+
+  Endpoints are always opened for overlapped I/O.
+  @param[in] adb_interface A handle to interface object created with 
+         AdbCreateInterface call.
+  @param[in] access_type Desired access type. In the current implementation
+         this parameter has no effect on the way endpoint is opened. It's
+         always read / write access.
+  @param[in] sharing_mode Desired share mode. In the current implementation
+         this parameter has no effect on the way endpoint is opened. It's
+         always shared for read / write.
+  @return Handle to the opened endpoint object or NULL on failure. If NULL is
+          returned GetLastError() provides extended error information.
+*/
+ADBWIN_API ADBAPIHANDLE __cdecl AdbOpenDefaultBulkWriteEndpoint(
+                            ADBAPIHANDLE adb_interface,
+                            AdbOpenAccessType access_type,
+                            AdbOpenSharingMode sharing_mode);
+
+/** \brief Gets handle to interface object for the given endpoint
+
+  @param[in] adb_endpoint A handle to opened endpoint object, obtained via one
+         of the AdbOpenXxxEndpoint calls.
+  @return Handle to the interface for this endpoint or NULL on failure. If NULL
+          is returned GetLastError() provides extended error information.
+*/
+ADBWIN_API ADBAPIHANDLE __cdecl AdbGetEndpointInterface(ADBAPIHANDLE adb_endpoint);
+
+/** \brief Gets information about the given endpoint.
+
+  @param[in] adb_endpoint A handle to opened endpoint object, obtained via one
+         of the AdbOpenXxxEndpoint calls.
+  @param[out] info Upon successful completion will have endpoint information.
+  @return true on success, false on failure. If false is returned
+          GetLastError() provides extended error information.
+*/
+ADBWIN_API bool __cdecl AdbQueryInformationEndpoint(ADBAPIHANDLE adb_endpoint,
+                                            AdbEndpointInformation* info);
+
+/** \brief Asynchronously reads from the given endpoint.
+
+  @param[in] adb_endpoint A handle to opened endpoint object, obtained via one
+         of the AdbOpenXxxEndpoint calls.
+  @param[out] buffer Pointer to the buffer that receives the data.
+  @param[in] bytes_to_read Number of bytes to be read.
+  @param[out] bytes_read Number of bytes read. Can be NULL.
+  @param[in] event_handle Event handle that should be signaled when async I/O
+         completes. Can be NULL. If it's not NULL this handle will be used to
+         initialize OVERLAPPED structure for this I/O.
+  @param[in] time_out A timeout (in milliseconds) required for this I/O to
+         complete. Zero value for this parameter means that there is no
+         timeout for this I/O.
+  @return A handle to IO completion object or NULL on failure. If NULL is
+          returned GetLastError() provides extended error information.
+*/
+ADBWIN_API ADBAPIHANDLE __cdecl AdbReadEndpointAsync(ADBAPIHANDLE adb_endpoint,
+                                             void* buffer,
+                                             unsigned long bytes_to_read,
+                                             unsigned long* bytes_read,
+                                             unsigned long time_out,
+                                             HANDLE event_handle);
+
+/** \brief Asynchronously writes to the given endpoint.
+
+  @param[in] adb_endpoint A handle to opened endpoint object, obtained via one
+         of the AdbOpenXxxEndpoint calls.
+  @param[in] buffer Pointer to the buffer containing the data to be written.
+  @param[in] bytes_to_write Number of bytes to be written.
+  @param[out] bytes_written Number of bytes written. Can be NULL.
+  @param[in] event_handle Event handle that should be signaled when async I/O
+         completes. Can be NULL. If it's not NULL this handle will be used to
+         initialize OVERLAPPED structure for this I/O.
+  @param[in] time_out A timeout (in milliseconds) required for this I/O to
+         complete. Zero value for this parameter means that there is no
+         timeout for this I/O.
+  @return A handle to IO completion object or NULL on failure. If NULL is
+          returned GetLastError() provides extended error information.
+*/
+ADBWIN_API ADBAPIHANDLE __cdecl AdbWriteEndpointAsync(ADBAPIHANDLE adb_endpoint,
+                                              void* buffer,
+                                              unsigned long bytes_to_write,
+                                              unsigned long* bytes_written,
+                                              unsigned long time_out,
+                                              HANDLE event_handle);
+
+/** \brief Synchronously reads from the given endpoint.
+
+  @param[in] adb_endpoint A handle to opened endpoint object, obtained via one
+         of the AdbOpenXxxEndpoint calls.
+  @param[out] buffer Pointer to the buffer that receives the data.
+  @param[in] bytes_to_read Number of bytes to be read.
+  @param[out] bytes_read Number of bytes read. Can be NULL.
+  @param[in] time_out A timeout (in milliseconds) required for this I/O to
+         complete. Zero value for this parameter means that there is no
+         timeout for this I/O.
+  @return true on success and false on failure. If false is
+          returned GetLastError() provides extended error information.
+*/
+ADBWIN_API bool __cdecl AdbReadEndpointSync(ADBAPIHANDLE adb_endpoint,
+                                    void* buffer,
+                                    unsigned long bytes_to_read,
+                                    unsigned long* bytes_read,
+                                    unsigned long time_out);
+
+/** \brief Synchronously writes to the given endpoint.
+
+  @param[in] adb_endpoint A handle to opened endpoint object, obtained via one
+         of the AdbOpenXxxEndpoint calls.
+  @param[in] buffer Pointer to the buffer containing the data to be written.
+  @param[in] bytes_to_write Number of bytes to be written.
+  @param[out] bytes_written Number of bytes written. Can be NULL.
+  @param[in] time_out A timeout (in milliseconds) required for this I/O to
+         complete. Zero value for this parameter means that there is no
+         timeout for this I/O.
+  @return true on success and false on failure. If false is
+          returned GetLastError() provides extended error information.
+*/
+ADBWIN_API bool __cdecl AdbWriteEndpointSync(ADBAPIHANDLE adb_endpoint,
+                                     void* buffer,
+                                     unsigned long bytes_to_write,
+                                     unsigned long* bytes_written,
+                                     unsigned long time_out);
+
+/** \brief Gets overlapped I/O result for async I/O performed on the
+  given endpoint.
+
+  @param[in] adb_io_completion A handle to an I/O completion object returned
+         from AdbRead/WriteAsync routines.
+  @param[out] ovl_data Buffer for the copy of this object's OVERLAPPED
+         structure. Can be NULL.
+  @param[out] bytes_transferred Pointer to a variable that receives the
+         number of bytes that were actually transferred by a read or write
+         operation. See SDK doc on GetOvelappedResult for more information.
+         Unlike regular GetOvelappedResult call this parameter can be NULL.
+  @param[in] wait If this parameter is true, the method does not return
+         until the operation has been completed. If this parameter is false
+         and the operation is still pending, the method returns false and
+         the GetLastError function returns ERROR_IO_INCOMPLETE.
+  @return true if I/O has been completed or false on failure or if request
+         is not yet completed. If false is returned GetLastError() provides
+         extended error information. If GetLastError returns
+         ERROR_IO_INCOMPLETE it means that I/O is not yet completed.
+*/
+ADBWIN_API bool __cdecl AdbGetOvelappedIoResult(ADBAPIHANDLE adb_io_completion,
+                                        LPOVERLAPPED overlapped,
+                                        unsigned long* bytes_transferred,
+                                        bool wait);
+
+/** \brief Checks if overlapped I/O has been completed.
+
+  @param[in] adb_io_completion A handle to an I/O completion object returned
+         from AdbRead/WriteAsync routines.
+  @return true if I/O has been completed or false if it's still
+          incomplete. Regardless of the returned value, caller should
+          check GetLastError to validate that handle was OK.
+*/
+ADBWIN_API bool __cdecl AdbHasOvelappedIoComplated(ADBAPIHANDLE adb_io_completion);
+
+/** \brief Closes handle previously opened with one of the API calls
+
+  @param[in] adb_handle ADB handle previously opened with one of the API calls
+  @return true on success or false on failure. If false is returned
+          GetLastError() provides extended error information.
+*/
+ADBWIN_API bool __cdecl AdbCloseHandle(ADBAPIHANDLE adb_handle);
+
+#endif  // ANDROID_USB_API_ADBWINAPI_H__
diff --git a/host/windows/usb/api/adb_helper_routines.cpp b/host/windows/usb/api/adb_helper_routines.cpp
index e45ff91c2..d029ec7b0 100644
--- a/host/windows/usb/api/adb_helper_routines.cpp
+++ b/host/windows/usb/api/adb_helper_routines.cpp
@@ -1,274 +1,285 @@
-/*
- * Copyright (C) 2009 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-/** \file
-  This file consists of implementation of helper routines used
-  in the API.
-*/
-
-#include "stdafx.h"
-#include "adb_api.h"
-#include "adb_api_legacy.h"
-#include "adb_helper_routines.h"
-#include "adb_interface_enum.h"
-
-bool GetSDKComplientParam(AdbOpenAccessType access_type,
-                          AdbOpenSharingMode sharing_mode,
-                          ULONG* desired_access,
-                          ULONG* desired_sharing) {
-  if (NULL != desired_access) {
-    switch (access_type) {
-      case AdbOpenAccessTypeReadWrite:
-        *desired_access = GENERIC_READ | GENERIC_WRITE;
-        break;
-
-      case AdbOpenAccessTypeRead:
-        *desired_access = GENERIC_READ;
-        break;
-
-      case AdbOpenAccessTypeWrite:
-        *desired_access = GENERIC_WRITE;
-        break;
-
-      case AdbOpenAccessTypeQueryInfo:
-        *desired_access = FILE_READ_ATTRIBUTES | FILE_READ_EA;
-        break;
-
-      default:
-        SetLastError(ERROR_INVALID_ACCESS);
-        return false;
-    }
-  }
-
-  if (NULL != desired_sharing) {
-    switch (sharing_mode) {
-      case AdbOpenSharingModeReadWrite:
-        *desired_sharing = FILE_SHARE_READ | FILE_SHARE_WRITE;
-        break;
-
-      case AdbOpenSharingModeRead:
-        *desired_sharing = FILE_SHARE_READ;
-        break;
-
-      case AdbOpenSharingModeWrite:
-        *desired_sharing = FILE_SHARE_WRITE;
-        break;
-
-      case AdbOpenSharingModeExclusive:
-        *desired_sharing = 0;
-        break;
-
-      default:
-        SetLastError(ERROR_INVALID_PARAMETER);
-        return false;
-    }
-  }
-
-  return true;
-}
-
-bool EnumerateDeviceInterfaces(HDEVINFO hardware_dev_info,
-                               GUID class_id,
-                               bool exclude_removed,
-                               bool active_only,
-                               AdbEnumInterfaceArray* interfaces) {
-  AdbEnumInterfaceArray tmp;
-  bool ret = false;
-
-  // Enumerate interfaces on this device
-  for (ULONG index = 0; ; index++) {
-    SP_DEVICE_INTERFACE_DATA interface_data;
-    interface_data.cbSize = sizeof(SP_DEVICE_INTERFACE_DATA);
-
-    // SetupDiEnumDeviceInterfaces() returns information about device
-    // interfaces exposed by one or more devices defined by our interface
-    // class. Each call returns information about one interface. The routine
-    // can be called repeatedly to get information about several interfaces
-    // exposed by one or more devices.
-    if (SetupDiEnumDeviceInterfaces(hardware_dev_info,
-                                    0, 
-                                    &class_id,
-                                    index,
-                                    &interface_data)) {
-      // Satisfy "exclude removed" and "active only" filters.
-      if ((!exclude_removed || (0 == (interface_data.Flags & SPINT_REMOVED))) &&
-          (!active_only || (interface_data.Flags & SPINT_ACTIVE))) {
-        std::wstring dev_name;
-
-        if (GetUsbDeviceName(hardware_dev_info, &interface_data, &dev_name)) {
-          try {
-            // Add new entry to the array
-            tmp.push_back(AdbInstanceEnumEntry(dev_name.c_str(),
-                                               interface_data.InterfaceClassGuid,
-                                               interface_data.Flags));
-          } catch (... ) {
-            SetLastError(ERROR_OUTOFMEMORY);
-            break;
-          }
-        } else {
-          // Something went wrong in getting device name
-          break;
-        }
-      }
-    } else {
-      if (ERROR_NO_MORE_ITEMS == GetLastError()) {
-        // There are no more items in the list. Enum is completed.
-        ret = true;
-        break;
-      } else {
-        // Something went wrong in SDK enum
-        break;
-      }
-    }
-  }
-
-  // On success, swap temp array with the returning one
-  if (ret)
-    interfaces->swap(tmp);
-
-  return ret;
-}
-
-bool EnumerateDeviceInterfaces(GUID class_id,
-                               ULONG flags,
-                               bool exclude_removed,
-                               bool active_only,
-                               AdbEnumInterfaceArray* interfaces) {
-  // Open a handle to the plug and play dev node.
-  // SetupDiGetClassDevs() returns a device information set that
-  // contains info on all installed devices of a specified class.
-  HDEVINFO hardware_dev_info =
-    SetupDiGetClassDevs(&class_id, NULL, NULL, flags);
-
-  bool ret = false;
-
-  if (INVALID_HANDLE_VALUE != hardware_dev_info) {
-    // Do the enum
-    ret = EnumerateDeviceInterfaces(hardware_dev_info,
-                                    class_id,
-                                    exclude_removed,
-                                    active_only,
-                                    interfaces);
-
-    // Preserve last error accross hardware_dev_info destruction
-    ULONG error_to_report = ret ? NO_ERROR : GetLastError();
-
-    SetupDiDestroyDeviceInfoList(hardware_dev_info);
-
-    if (NO_ERROR != error_to_report)
-      SetLastError(error_to_report);
-  }
-
-  return ret;
-}
-
-bool GetUsbDeviceDetails(
-    HDEVINFO hardware_dev_info,
-    PSP_DEVICE_INTERFACE_DATA dev_info_data,
-    PSP_DEVICE_INTERFACE_DETAIL_DATA* dev_info_detail_data) {
-  ULONG required_len = 0;
-
-  // First query for the structure size. At this point we expect this call
-  // to fail with ERROR_INSUFFICIENT_BUFFER error code.
-  if (SetupDiGetDeviceInterfaceDetail(hardware_dev_info,
-                                      dev_info_data,
-                                      NULL,
-                                      0,
-                                      &required_len,
-                                      NULL)) {
-    return false;
-  }
-
-  if (ERROR_INSUFFICIENT_BUFFER != GetLastError())
-    return false;
-
-  // Allocate buffer for the structure
-  PSP_DEVICE_INTERFACE_DETAIL_DATA buffer =
-    reinterpret_cast<PSP_DEVICE_INTERFACE_DETAIL_DATA>(malloc(required_len));
-
-  if (NULL == buffer) {
-    SetLastError(ERROR_OUTOFMEMORY);
-    return false;
-  }
-
-  buffer->cbSize = sizeof(SP_DEVICE_INTERFACE_DETAIL_DATA);
-
-  // Retrieve the information from Plug and Play.
-  if (SetupDiGetDeviceInterfaceDetail(hardware_dev_info,
-                                      dev_info_data,
-                                      buffer,
-                                      required_len,
-                                      &required_len,
-                                      NULL)) {
-    *dev_info_detail_data = buffer;
-    return true;
-  } else {
-    // Free the buffer if this call failed
-    free(buffer);
-
-    return false;
-  }
-}
-
-bool GetUsbDeviceName(HDEVINFO hardware_dev_info,
-                      PSP_DEVICE_INTERFACE_DATA dev_info_data,
-                      std::wstring* name) {
-  PSP_DEVICE_INTERFACE_DETAIL_DATA func_class_dev_data = NULL;
-  if (!GetUsbDeviceDetails(hardware_dev_info,
-                           dev_info_data,
-                           &func_class_dev_data)) {
-    return false;
-  }
-
-  try {
-    *name = func_class_dev_data->DevicePath;
-  } catch (...) {
-    SetLastError(ERROR_OUTOFMEMORY);
-  }
-
-  free(func_class_dev_data);
-
-  return !name->empty();
-}
-
-bool IsLegacyInterface(const wchar_t* interface_name) {
-  // Open USB device for this intefface
-  HANDLE usb_device_handle = CreateFile(interface_name,
-                                        GENERIC_READ | GENERIC_WRITE,
-                                        FILE_SHARE_READ | FILE_SHARE_WRITE,
-                                        NULL,
-                                        OPEN_EXISTING,
-                                        0,
-                                        NULL);
-  if (INVALID_HANDLE_VALUE == usb_device_handle)
-    return NULL;
-
-  // Try to issue ADB_IOCTL_GET_USB_DEVICE_DESCRIPTOR IOCTL that is supported
-  // by the legacy driver, but is not implemented in the WinUsb driver.
-  DWORD ret_bytes = 0;
-  USB_DEVICE_DESCRIPTOR descriptor;
-  BOOL ret = DeviceIoControl(usb_device_handle,
-                             ADB_IOCTL_GET_USB_DEVICE_DESCRIPTOR,
-                             NULL, 0,
-                             &descriptor,
-                             sizeof(descriptor),
-                             &ret_bytes,
-                             NULL);
-  ::CloseHandle(usb_device_handle);
-
-  // If IOCTL succeeded we've got legacy driver underneath.
-  return ret ? true : false;
-}
+/*
+ * Copyright (C) 2009 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+/** \file
+  This file consists of implementation of helper routines used
+  in the API.
+*/
+
+#include "stdafx.h"
+#include "adb_api.h"
+#include "adb_api_legacy.h"
+#include "adb_helper_routines.h"
+#include "adb_interface_enum.h"
+
+bool GetSDKComplientParam(AdbOpenAccessType access_type,
+                          AdbOpenSharingMode sharing_mode,
+                          ULONG* desired_access,
+                          ULONG* desired_sharing) {
+  if (NULL != desired_access) {
+    switch (access_type) {
+      case AdbOpenAccessTypeReadWrite:
+        *desired_access = GENERIC_READ | GENERIC_WRITE;
+        break;
+
+      case AdbOpenAccessTypeRead:
+        *desired_access = GENERIC_READ;
+        break;
+
+      case AdbOpenAccessTypeWrite:
+        *desired_access = GENERIC_WRITE;
+        break;
+
+      case AdbOpenAccessTypeQueryInfo:
+        *desired_access = FILE_READ_ATTRIBUTES | FILE_READ_EA;
+        break;
+
+      default:
+        SetLastError(ERROR_INVALID_ACCESS);
+        return false;
+    }
+  }
+
+  if (NULL != desired_sharing) {
+    switch (sharing_mode) {
+      case AdbOpenSharingModeReadWrite:
+        *desired_sharing = FILE_SHARE_READ | FILE_SHARE_WRITE;
+        break;
+
+      case AdbOpenSharingModeRead:
+        *desired_sharing = FILE_SHARE_READ;
+        break;
+
+      case AdbOpenSharingModeWrite:
+        *desired_sharing = FILE_SHARE_WRITE;
+        break;
+
+      case AdbOpenSharingModeExclusive:
+        *desired_sharing = 0;
+        break;
+
+      default:
+        SetLastError(ERROR_INVALID_PARAMETER);
+        return false;
+    }
+  }
+
+  return true;
+}
+
+bool EnumerateDeviceInterfaces(HDEVINFO hardware_dev_info,
+                               GUID class_id,
+                               bool exclude_removed,
+                               bool active_only,
+                               AdbEnumInterfaceArray* interfaces) {
+  AdbEnumInterfaceArray tmp;
+  bool ret = false;
+
+  // Enumerate interfaces on this device
+  for (ULONG index = 0; ; index++) {
+    SP_DEVICE_INTERFACE_DATA interface_data;
+    interface_data.cbSize = sizeof(SP_DEVICE_INTERFACE_DATA);
+
+    // SetupDiEnumDeviceInterfaces() returns information about device
+    // interfaces exposed by one or more devices defined by our interface
+    // class. Each call returns information about one interface. The routine
+    // can be called repeatedly to get information about several interfaces
+    // exposed by one or more devices.
+    if (SetupDiEnumDeviceInterfaces(hardware_dev_info,
+                                    0, 
+                                    &class_id,
+                                    index,
+                                    &interface_data)) {
+      // Satisfy "exclude removed" and "active only" filters.
+      if ((!exclude_removed || (0 == (interface_data.Flags & SPINT_REMOVED))) &&
+          (!active_only || (interface_data.Flags & SPINT_ACTIVE))) {
+        std::wstring dev_name;
+
+        if (GetUsbDeviceName(hardware_dev_info, &interface_data, &dev_name)) {
+          try {
+            // Add new entry to the array
+            tmp.push_back(AdbInstanceEnumEntry(dev_name.c_str(),
+                                               interface_data.InterfaceClassGuid,
+                                               interface_data.Flags));
+          } catch (... ) {
+            SetLastError(ERROR_OUTOFMEMORY);
+            break;
+          }
+        } else {
+          // Something went wrong in getting device name
+          break;
+        }
+      }
+    } else {
+      if (ERROR_NO_MORE_ITEMS == GetLastError()) {
+        // There are no more items in the list. Enum is completed.
+        ret = true;
+        break;
+      } else {
+        // Something went wrong in SDK enum
+        break;
+      }
+    }
+  }
+
+  // On success, swap temp array with the returning one
+  if (ret)
+    interfaces->swap(tmp);
+
+  return ret;
+}
+
+bool EnumerateDeviceInterfaces(GUID class_id,
+                               ULONG flags,
+                               bool exclude_removed,
+                               bool active_only,
+                               AdbEnumInterfaceArray* interfaces) {
+  // Open a handle to the plug and play dev node.
+  // SetupDiGetClassDevs() returns a device information set that
+  // contains info on all installed devices of a specified class.
+  HDEVINFO hardware_dev_info =
+    SetupDiGetClassDevs(&class_id, NULL, NULL, flags);
+
+  bool ret = false;
+
+  if (INVALID_HANDLE_VALUE != hardware_dev_info) {
+    // Do the enum
+    ret = EnumerateDeviceInterfaces(hardware_dev_info,
+                                    class_id,
+                                    exclude_removed,
+                                    active_only,
+                                    interfaces);
+
+    // Preserve last error accross hardware_dev_info destruction
+    ULONG error_to_report = ret ? NO_ERROR : GetLastError();
+
+    SetupDiDestroyDeviceInfoList(hardware_dev_info);
+
+    if (NO_ERROR != error_to_report)
+      SetLastError(error_to_report);
+  }
+
+  return ret;
+}
+
+bool GetUsbDeviceDetails(
+    HDEVINFO hardware_dev_info,
+    PSP_DEVICE_INTERFACE_DATA dev_info_data,
+    PSP_DEVICE_INTERFACE_DETAIL_DATA* dev_info_detail_data) {
+  ULONG required_len = 0;
+
+  // First query for the structure size. At this point we expect this call
+  // to fail with ERROR_INSUFFICIENT_BUFFER error code.
+  if (SetupDiGetDeviceInterfaceDetail(hardware_dev_info,
+                                      dev_info_data,
+                                      NULL,
+                                      0,
+                                      &required_len,
+                                      NULL)) {
+    return false;
+  }
+
+  if (ERROR_INSUFFICIENT_BUFFER != GetLastError())
+    return false;
+
+  // Allocate buffer for the structure
+  PSP_DEVICE_INTERFACE_DETAIL_DATA buffer =
+    reinterpret_cast<PSP_DEVICE_INTERFACE_DETAIL_DATA>(malloc(required_len));
+
+  if (NULL == buffer) {
+    SetLastError(ERROR_OUTOFMEMORY);
+    return false;
+  }
+
+  buffer->cbSize = sizeof(SP_DEVICE_INTERFACE_DETAIL_DATA);
+
+  // Retrieve the information from Plug and Play.
+  if (SetupDiGetDeviceInterfaceDetail(hardware_dev_info,
+                                      dev_info_data,
+                                      buffer,
+                                      required_len,
+                                      &required_len,
+                                      NULL)) {
+    *dev_info_detail_data = buffer;
+    return true;
+  } else {
+    // Free the buffer if this call failed
+    free(buffer);
+
+    return false;
+  }
+}
+
+bool GetUsbDeviceName(HDEVINFO hardware_dev_info,
+                      PSP_DEVICE_INTERFACE_DATA dev_info_data,
+                      std::wstring* name) {
+  PSP_DEVICE_INTERFACE_DETAIL_DATA func_class_dev_data = NULL;
+  if (!GetUsbDeviceDetails(hardware_dev_info,
+                           dev_info_data,
+                           &func_class_dev_data)) {
+    return false;
+  }
+
+  try {
+    // convert to std::string for str.length();
+    std::string tmp_str(func_class_dev_data->DevicePath);
+    size_t sz = tmp_str.length();
+    
+    // convert to wchar_t array
+    wchar_t tmp[sz];
+    mbstowcs(tmp, func_class_dev_data->DevicePath, sz);
+
+    // null terminate
+    tmp[sz] = '\0';
+
+    *name = tmp;
+  } catch (...) {
+    SetLastError(ERROR_OUTOFMEMORY);
+  }
+
+  free(func_class_dev_data);
+
+  return !name->empty();
+}
+
+bool IsLegacyInterface(const wchar_t* interface_name) {
+  // Open USB device for this intefface
+  HANDLE usb_device_handle = CreateFileW(interface_name,
+                                        GENERIC_READ | GENERIC_WRITE,
+                                        FILE_SHARE_READ | FILE_SHARE_WRITE,
+                                        NULL,
+                                        OPEN_EXISTING,
+                                        0,
+                                        NULL);
+  if (INVALID_HANDLE_VALUE == usb_device_handle)
+    return NULL;
+
+  // Try to issue ADB_IOCTL_GET_USB_DEVICE_DESCRIPTOR IOCTL that is supported
+  // by the legacy driver, but is not implemented in the WinUsb driver.
+  DWORD ret_bytes = 0;
+  USB_DEVICE_DESCRIPTOR descriptor;
+  BOOL ret = DeviceIoControl(usb_device_handle,
+                             ADB_IOCTL_GET_USB_DEVICE_DESCRIPTOR,
+                             NULL, 0,
+                             &descriptor,
+                             sizeof(descriptor),
+                             &ret_bytes,
+                             NULL);
+  ::CloseHandle(usb_device_handle);
+
+  // If IOCTL succeeded we've got legacy driver underneath.
+  return ret ? true : false;
+}
diff --git a/host/windows/usb/api/adb_interface.cpp b/host/windows/usb/api/adb_interface.cpp
index a0803aa83..9eff21ae8 100644
--- a/host/windows/usb/api/adb_interface.cpp
+++ b/host/windows/usb/api/adb_interface.cpp
@@ -1,117 +1,116 @@
-/*
- * Copyright (C) 2006 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-/** \file
-  This file consists of implementation of class AdbInterfaceObject that
-  encapsulates a generic interface on our USB device.
-*/
-
-#include "stdafx.h"
-#include "adb_interface.h"
-
-AdbInterfaceObject::AdbInterfaceObject(const wchar_t* interf_name)
-    : AdbObjectHandle(AdbObjectTypeInterface),
-      interface_name_(interf_name) {
-  ATLASSERT(NULL != interf_name);
-}
-
-AdbInterfaceObject::~AdbInterfaceObject() {
-}
-
-bool AdbInterfaceObject::GetInterfaceName(void* buffer,
-                                          unsigned long* buffer_char_size,
-                                          bool ansi) {
-  if (NULL == buffer_char_size) {
-    SetLastError(ERROR_INVALID_PARAMETER);
-    return false;
-  }
-
-  // Lets see if buffer is big enough
-  ULONG name_len = static_cast<ULONG>(interface_name_.length() + 1);
-  if ((NULL == buffer) || (*buffer_char_size < name_len)) {
-    *buffer_char_size = name_len;
-    SetLastError(ERROR_INSUFFICIENT_BUFFER);
-    return false;
-  }
-
-  if (!ansi) {
-    // If user asked for wide char name just return it
-    wcscpy(reinterpret_cast<wchar_t*>(buffer), interface_name().c_str());
-    return true;
-  }
-
-  // We need to convert name from wide char to ansi string
-  int res = WideCharToMultiByte(CP_ACP,
-                                0,
-                                interface_name().c_str(),
-                                static_cast<int>(name_len),
-                                reinterpret_cast<PSTR>(buffer),
-                                static_cast<int>(*buffer_char_size),
-                                NULL,
-                                NULL);
-  return (res != 0);
-}
-
-bool AdbInterfaceObject::GetUsbDeviceDescriptor(USB_DEVICE_DESCRIPTOR* desc) {
-  if (!IsOpened()) {
-    SetLastError(ERROR_INVALID_HANDLE);
-    return false;
-  }
-
-  if (NULL == desc) {
-    SetLastError(ERROR_INVALID_PARAMETER);
-    return false;
-  }
-
-  CopyMemory(desc, usb_device_descriptor(), sizeof(USB_DEVICE_DESCRIPTOR));
-
-  return true;
-}
-
-bool AdbInterfaceObject::GetUsbConfigurationDescriptor(
-    USB_CONFIGURATION_DESCRIPTOR* desc) {
-  if (!IsOpened()) {
-    SetLastError(ERROR_INVALID_HANDLE);
-    return false;
-  }
-
-  if (NULL == desc) {
-    SetLastError(ERROR_INVALID_PARAMETER);
-    return false;
-  }
-
-  CopyMemory(desc, usb_config_descriptor(),
-             sizeof(USB_CONFIGURATION_DESCRIPTOR));
-
-  return true;
-}
-
-bool AdbInterfaceObject::GetUsbInterfaceDescriptor(
-    USB_INTERFACE_DESCRIPTOR* desc) {
-  if (!IsOpened()) {
-    SetLastError(ERROR_INVALID_HANDLE);
-    return false;
-  }
-
-  if (NULL == desc) {
-    SetLastError(ERROR_INVALID_PARAMETER);
-    return false;
-  }
-
-  CopyMemory(desc, usb_interface_descriptor(), sizeof(USB_INTERFACE_DESCRIPTOR));
-
-  return true;
-}
+/*
+ * Copyright (C) 2006 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+/** \file
+  This file consists of implementation of class AdbInterfaceObject that
+  encapsulates a generic interface on our USB device.
+*/
+
+#include "stdafx.h"
+#include "adb_interface.h"
+
+AdbInterfaceObject::AdbInterfaceObject(const wchar_t* interf_name)
+    : AdbObjectHandle(AdbObjectTypeInterface),
+      interface_name_(interf_name) {
+}
+
+AdbInterfaceObject::~AdbInterfaceObject() {
+}
+
+bool AdbInterfaceObject::GetInterfaceName(void* buffer,
+                                          unsigned long* buffer_char_size,
+                                          bool ansi) {
+  if (NULL == buffer_char_size) {
+    SetLastError(ERROR_INVALID_PARAMETER);
+    return false;
+  }
+
+  // Lets see if buffer is big enough
+  ULONG name_len = static_cast<ULONG>(interface_name_.length() + 1);
+  if ((NULL == buffer) || (*buffer_char_size < name_len)) {
+    *buffer_char_size = name_len;
+    SetLastError(ERROR_INSUFFICIENT_BUFFER);
+    return false;
+  }
+
+  if (!ansi) {
+    // If user asked for wide char name just return it
+    wcscpy(reinterpret_cast<wchar_t*>(buffer), interface_name().c_str());
+    return true;
+  }
+
+  // We need to convert name from wide char to ansi string
+  int res = WideCharToMultiByte(CP_ACP,
+                                0,
+                                interface_name().c_str(),
+                                static_cast<int>(name_len),
+                                reinterpret_cast<PSTR>(buffer),
+                                static_cast<int>(*buffer_char_size),
+                                NULL,
+                                NULL);
+  return (res != 0);
+}
+
+bool AdbInterfaceObject::GetUsbDeviceDescriptor(USB_DEVICE_DESCRIPTOR* desc) {
+  if (!IsOpened()) {
+    SetLastError(ERROR_INVALID_HANDLE);
+    return false;
+  }
+
+  if (NULL == desc) {
+    SetLastError(ERROR_INVALID_PARAMETER);
+    return false;
+  }
+
+  CopyMemory(desc, usb_device_descriptor(), sizeof(USB_DEVICE_DESCRIPTOR));
+
+  return true;
+}
+
+bool AdbInterfaceObject::GetUsbConfigurationDescriptor(
+    USB_CONFIGURATION_DESCRIPTOR* desc) {
+  if (!IsOpened()) {
+    SetLastError(ERROR_INVALID_HANDLE);
+    return false;
+  }
+
+  if (NULL == desc) {
+    SetLastError(ERROR_INVALID_PARAMETER);
+    return false;
+  }
+
+  CopyMemory(desc, usb_config_descriptor(),
+             sizeof(USB_CONFIGURATION_DESCRIPTOR));
+
+  return true;
+}
+
+bool AdbInterfaceObject::GetUsbInterfaceDescriptor(
+    USB_INTERFACE_DESCRIPTOR* desc) {
+  if (!IsOpened()) {
+    SetLastError(ERROR_INVALID_HANDLE);
+    return false;
+  }
+
+  if (NULL == desc) {
+    SetLastError(ERROR_INVALID_PARAMETER);
+    return false;
+  }
+
+  CopyMemory(desc, usb_interface_descriptor(), sizeof(USB_INTERFACE_DESCRIPTOR));
+
+  return true;
+}
diff --git a/host/windows/usb/api/adb_interface_enum.cpp b/host/windows/usb/api/adb_interface_enum.cpp
index 094cd3ea7..c587b5419 100644
--- a/host/windows/usb/api/adb_interface_enum.cpp
+++ b/host/windows/usb/api/adb_interface_enum.cpp
@@ -1,103 +1,102 @@
-/*
- * Copyright (C) 2006 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-/** \file
-  This file consists of implementation of AdbInterfaceEnumObject class that
-  encapsulates enumerator of USB interfaces available through this API.
-*/
-
-#include "stdafx.h"
-#include "adb_api.h"
-#include "adb_interface_enum.h"
-#include "adb_helper_routines.h"
-
-AdbInterfaceEnumObject::AdbInterfaceEnumObject()
-    : AdbObjectHandle(AdbObjectTypeInterfaceEnumerator) {
-  current_interface_ = interfaces_.begin();
-}
-
-AdbInterfaceEnumObject::~AdbInterfaceEnumObject() {
-}
-
-bool AdbInterfaceEnumObject::InitializeEnum(GUID class_id,
-                                            bool exclude_not_present,
-                                            bool exclude_removed,
-                                            bool active_only) {
-  // Calc flags for SetupDiGetClassDevs
-  DWORD flags = DIGCF_DEVICEINTERFACE;
-  if (exclude_not_present)
-    flags |= DIGCF_PRESENT;
-
-  // Do the enum
-  bool ret = EnumerateDeviceInterfaces(class_id,
-                                       flags,
-                                       exclude_removed,
-                                       active_only,
-                                       &interfaces_);
-
-  // If enum was successfull set current enum pointer
-  // to the beginning of the array
-  if (ret)
-    current_interface_ = interfaces_.begin();
-
-  return ret;
-}
-
-bool AdbInterfaceEnumObject::Next(AdbInterfaceInfo* info, ULONG* size) {
-  // Make sure that it's opened
-  if (!IsOpened()) {
-    SetLastError(ERROR_INVALID_HANDLE);
-    return false;
-  }
-
-  ATLASSERT(NULL != size);
-  if (NULL == size) {
-    SetLastError(ERROR_INVALID_PARAMETER);
-    return false;
-  }
-
-  // Lets see if enum is over
-  if (interfaces_.end() == current_interface_) {
-    SetLastError(ERROR_NO_MORE_ITEMS);
-    return false;
-  }
-
-  AdbInstanceEnumEntry& entry = *current_interface_;
-
-  // Big enough?
-  if ((NULL == info) || (*size < entry.GetFlatSize())) {
-    *size = entry.GetFlatSize();
-    SetLastError(ERROR_INSUFFICIENT_BUFFER);
-    return false;
-  }
-
-  // All checks passed
-  entry.Save(info);
-  current_interface_++;
-  return true;
-}
-
-bool AdbInterfaceEnumObject::Reset() {
-  // Make sure that it's opened
-  if (!IsOpened()) {
-    SetLastError(ERROR_INVALID_HANDLE);
-    return false;
-  }
-
-  current_interface_ = interfaces_.begin();
-
-  return true;
-}
+/*
+ * Copyright (C) 2006 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+/** \file
+  This file consists of implementation of AdbInterfaceEnumObject class that
+  encapsulates enumerator of USB interfaces available through this API.
+*/
+
+#include "stdafx.h"
+#include "adb_api.h"
+#include "adb_interface_enum.h"
+#include "adb_helper_routines.h"
+
+AdbInterfaceEnumObject::AdbInterfaceEnumObject()
+    : AdbObjectHandle(AdbObjectTypeInterfaceEnumerator) {
+  current_interface_ = interfaces_.begin();
+}
+
+AdbInterfaceEnumObject::~AdbInterfaceEnumObject() {
+}
+
+bool AdbInterfaceEnumObject::InitializeEnum(GUID class_id,
+                                            bool exclude_not_present,
+                                            bool exclude_removed,
+                                            bool active_only) {
+  // Calc flags for SetupDiGetClassDevs
+  DWORD flags = DIGCF_DEVICEINTERFACE;
+  if (exclude_not_present)
+    flags |= DIGCF_PRESENT;
+
+  // Do the enum
+  bool ret = EnumerateDeviceInterfaces(class_id,
+                                       flags,
+                                       exclude_removed,
+                                       active_only,
+                                       &interfaces_);
+
+  // If enum was successfull set current enum pointer
+  // to the beginning of the array
+  if (ret)
+    current_interface_ = interfaces_.begin();
+
+  return ret;
+}
+
+bool AdbInterfaceEnumObject::Next(AdbInterfaceInfo* info, ULONG* size) {
+  // Make sure that it's opened
+  if (!IsOpened()) {
+    SetLastError(ERROR_INVALID_HANDLE);
+    return false;
+  }
+
+  if (NULL == size) {
+    SetLastError(ERROR_INVALID_PARAMETER);
+    return false;
+  }
+
+  // Lets see if enum is over
+  if (interfaces_.end() == current_interface_) {
+    SetLastError(ERROR_NO_MORE_ITEMS);
+    return false;
+  }
+
+  AdbInstanceEnumEntry& entry = *current_interface_;
+
+  // Big enough?
+  if ((NULL == info) || (*size < entry.GetFlatSize())) {
+    *size = entry.GetFlatSize();
+    SetLastError(ERROR_INSUFFICIENT_BUFFER);
+    return false;
+  }
+
+  // All checks passed
+  entry.Save(info);
+  current_interface_++;
+  return true;
+}
+
+bool AdbInterfaceEnumObject::Reset() {
+  // Make sure that it's opened
+  if (!IsOpened()) {
+    SetLastError(ERROR_INVALID_HANDLE);
+    return false;
+  }
+
+  current_interface_ = interfaces_.begin();
+
+  return true;
+}
diff --git a/host/windows/usb/api/adb_io_completion.cpp b/host/windows/usb/api/adb_io_completion.cpp
index 6575e0351..82e2b9744 100644
--- a/host/windows/usb/api/adb_io_completion.cpp
+++ b/host/windows/usb/api/adb_io_completion.cpp
@@ -1,50 +1,49 @@
-/*
- * Copyright (C) 2009 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-/** \file
-  This file consists of implementation of class AdbIOCompletion that
-  encapsulates a generic wrapper around OVERLAPPED Win32 structure
-  returned from asynchronous I/O requests.
-*/
-
-#include "stdafx.h"
-#include "adb_io_completion.h"
-
-AdbIOCompletion::AdbIOCompletion(AdbEndpointObject* parent_io_obj,
-                                 ULONG expected_trans_size,
-                                 HANDLE event_hndl)
-    : AdbObjectHandle(AdbObjectTypeIoCompletion),
-      expected_transfer_size_(expected_trans_size),
-      parent_io_object_(parent_io_obj) {
-  ATLASSERT(NULL != parent_io_obj);
-  parent_io_obj->AddRef();
-  ZeroMemory(&overlapped_, sizeof(overlapped_));
-  overlapped_.hEvent = event_hndl;
-}
-
-AdbIOCompletion::~AdbIOCompletion() {
-  parent_io_object_->Release();
-}
-
-bool AdbIOCompletion::IsCompleted() {
-  SetLastError(NO_ERROR);
-  if (!IsOpened()) {
-    SetLastError(ERROR_INVALID_HANDLE);
-    return true;
-  }
-
-  return HasOverlappedIoCompleted(overlapped()) ? true : false;
-}
+/*
+ * Copyright (C) 2009 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+/** \file
+  This file consists of implementation of class AdbIOCompletion that
+  encapsulates a generic wrapper around OVERLAPPED Win32 structure
+  returned from asynchronous I/O requests.
+*/
+
+#include "stdafx.h"
+#include "adb_io_completion.h"
+
+AdbIOCompletion::AdbIOCompletion(AdbEndpointObject* parent_io_obj,
+                                 ULONG expected_trans_size,
+                                 HANDLE event_hndl)
+    : AdbObjectHandle(AdbObjectTypeIoCompletion),
+      expected_transfer_size_(expected_trans_size),
+      parent_io_object_(parent_io_obj) {
+  parent_io_obj->AddRef();
+  ZeroMemory(&overlapped_, sizeof(overlapped_));
+  overlapped_.hEvent = event_hndl;
+}
+
+AdbIOCompletion::~AdbIOCompletion() {
+  parent_io_object_->Release();
+}
+
+bool AdbIOCompletion::IsCompleted() {
+  SetLastError(NO_ERROR);
+  if (!IsOpened()) {
+    SetLastError(ERROR_INVALID_HANDLE);
+    return true;
+  }
+
+  return HasOverlappedIoCompleted(overlapped()) ? true : false;
+}
diff --git a/host/windows/usb/api/adb_legacy_endpoint_object.cpp b/host/windows/usb/api/adb_legacy_endpoint_object.cpp
index 2baa53b3d..0fe5606fb 100755
--- a/host/windows/usb/api/adb_legacy_endpoint_object.cpp
+++ b/host/windows/usb/api/adb_legacy_endpoint_object.cpp
@@ -1,237 +1,237 @@
-/*
- * Copyright (C) 2009 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-/** \file
-  This file consists of implementation of class AdbLegacyEndpointObject that
-  encapsulates a handle opened to an endpoint on our device controlled by
-  a custom (legacy) USB driver.
-*/
-
-#include "stdafx.h"
-#include "adb_api_legacy.h"
-#include "adb_legacy_endpoint_object.h"
-#include "adb_legacy_io_completion.h"
-#include "adb_helper_routines.h"
-
-AdbLegacyEndpointObject::AdbLegacyEndpointObject(
-    AdbLegacyInterfaceObject* parent_interf,
-    UCHAR endpoint_id,
-    UCHAR endpoint_index)
-    : AdbEndpointObject(parent_interf, endpoint_id, endpoint_index),
-      usb_handle_(INVALID_HANDLE_VALUE) {
-}
-
-AdbLegacyEndpointObject::~AdbLegacyEndpointObject() {
-  if (INVALID_HANDLE_VALUE != usb_handle_) {
-    ::CloseHandle(usb_handle_);
-  }
-}
-
-ADBAPIHANDLE AdbLegacyEndpointObject::CommonAsyncReadWrite(
-    bool is_read,
-    void* buffer,
-    ULONG bytes_to_transfer,
-    ULONG* bytes_transferred,
-    HANDLE event_handle,
-    ULONG time_out) {
-  if (NULL != bytes_transferred) {
-    *bytes_transferred = 0;
-  }
-
-  if (!IsOpened()) {
-    SetLastError(ERROR_INVALID_HANDLE);
-    return false;
-  }
-
-  bool is_ioctl_write = is_read ? false : (0 != time_out);
-
-  // Create completion i/o object
-  AdbLegacyIOCompletion* adb_io_completion = NULL;
-
-  try {
-    adb_io_completion = new AdbLegacyIOCompletion(this,
-                                                  bytes_to_transfer,
-                                                  event_handle,
-                                                  is_ioctl_write);
-  } catch (... ) {
-    // We don't expect exceptions other than OOM thrown here.
-    SetLastError(ERROR_OUTOFMEMORY);
-    return NULL;
-  }
-
-  // Create a handle for it
-  ADBAPIHANDLE ret = adb_io_completion->CreateHandle();
-  ULONG transferred = 0;
-  if (NULL != ret) {
-    BOOL res = TRUE;
-    if (0 == time_out) {
-      // Go the read / write file way
-      res = is_read ? ReadFile(usb_handle(),
-                               buffer,
-                               bytes_to_transfer,
-                               &transferred,
-                               adb_io_completion->overlapped()) :
-                      WriteFile(usb_handle(),
-                                buffer,
-                                bytes_to_transfer,
-                                &transferred,
-                                adb_io_completion->overlapped());
-    } else {
-      // Go IOCTL way
-      AdbBulkTransfer transfer_param;
-      transfer_param.time_out = time_out;
-      transfer_param.transfer_size = is_read ? 0 : bytes_to_transfer;
-      transfer_param.SetWriteBuffer(is_read ? NULL : buffer);
-
-      res = DeviceIoControl(usb_handle(),
-        is_read ? ADB_IOCTL_BULK_READ : ADB_IOCTL_BULK_WRITE,
-        &transfer_param, sizeof(transfer_param),
-        is_read ? buffer : adb_io_completion->transferred_bytes_ptr(),
-        is_read ? bytes_to_transfer : sizeof(ULONG),
-        &transferred,
-        adb_io_completion->overlapped());
-    }
-
-    if (NULL != bytes_transferred) {
-      *bytes_transferred = transferred;
-    }
-
-    ULONG error = GetLastError();
-    if (!res && (ERROR_IO_PENDING != error)) {
-      // I/O failed immediatelly. We need to close i/o completion object
-      // before we return NULL to the caller.
-      adb_io_completion->CloseHandle();
-      ret = NULL;
-      SetLastError(error);
-    }
-  }
-
-  // Offseting 'new'
-  adb_io_completion->Release();
-
-  return ret;
-}
-
-bool AdbLegacyEndpointObject::CommonSyncReadWrite(bool is_read,
-                                                  void* buffer,
-                                                  ULONG bytes_to_transfer,
-                                                  ULONG* bytes_transferred,
-                                                  ULONG time_out) {
-  if (NULL != bytes_transferred) {
-    *bytes_transferred = 0;
-  }
-
-  if (!IsOpened()) {
-    SetLastError(ERROR_INVALID_HANDLE);
-    return false;
-  }
-
-  bool is_ioctl_write = is_read ? false : (0 != time_out);
-
-  // This is synchronous I/O. Since we always open I/O items for
-  // overlapped I/O we're obligated to always provide OVERLAPPED
-  // structure to read / write routines. Prepare it now.
-  OVERLAPPED overlapped;
-  ZeroMemory(&overlapped, sizeof(overlapped));
-
-  BOOL ret = TRUE;
-  ULONG ioctl_write_transferred = 0;
-  if (0 == time_out) {
-    // Go the read / write file way
-    ret = is_read ?
-      ReadFile(usb_handle(), buffer, bytes_to_transfer, bytes_transferred, &overlapped) :
-      WriteFile(usb_handle(), buffer, bytes_to_transfer, bytes_transferred, &overlapped);
-  } else {
-    // Go IOCTL way
-    AdbBulkTransfer transfer_param;
-    transfer_param.time_out = time_out;
-    transfer_param.transfer_size = is_read ? 0 : bytes_to_transfer;
-    transfer_param.SetWriteBuffer(is_read ? NULL : buffer);
-
-    ULONG tmp;
-    ret = DeviceIoControl(usb_handle(),
-      is_read ? ADB_IOCTL_BULK_READ : ADB_IOCTL_BULK_WRITE,
-      &transfer_param, sizeof(transfer_param),
-      is_read ? buffer : &ioctl_write_transferred,
-      is_read ? bytes_to_transfer : sizeof(ULONG),
-      &tmp,
-      &overlapped);
-  }
-
-  // Lets see the result
-  if (!ret && (ERROR_IO_PENDING != GetLastError())) {
-    // I/O failed.
-    return false;
-  }
-
-  // Lets wait till I/O completes
-  ULONG transferred = 0;
-  ret = GetOverlappedResult(usb_handle(), &overlapped, &transferred, TRUE);
-  if (ret && (NULL != bytes_transferred)) {
-    *bytes_transferred = is_ioctl_write ? ioctl_write_transferred :
-                                          transferred;
-  }
-
-  return ret ? true : false;
-}
-
-ADBAPIHANDLE AdbLegacyEndpointObject::CreateHandle(
-    const wchar_t* item_path,
-    AdbOpenAccessType access_type,
-    AdbOpenSharingMode share_mode) {
-  // Convert access / share parameters into CreateFile - compatible
-  ULONG desired_access;
-  ULONG desired_sharing;
-
-  if (!GetSDKComplientParam(access_type, share_mode,
-                            &desired_access, &desired_sharing)) {
-    return NULL;
-  }
-
-  // Open USB handle
-  usb_handle_ = CreateFile(item_path,
-                           desired_access,
-                           share_mode,
-                           NULL,
-                           OPEN_EXISTING,
-                           FILE_FLAG_OVERLAPPED,  // Always overlapped!
-                           NULL);
-  if (INVALID_HANDLE_VALUE == usb_handle_) {
-    return NULL;
-  }
-
-  // Create ADB handle
-  ADBAPIHANDLE ret = AdbObjectHandle::CreateHandle();
-
-  if (NULL == ret) {
-    // If creation of ADB handle failed we have to close USB handle too.
-    ULONG error = GetLastError();
-    ::CloseHandle(usb_handle());
-    usb_handle_ = INVALID_HANDLE_VALUE;
-    SetLastError(error);
-  }
-
-  return ret;
-}
-
-bool AdbLegacyEndpointObject::CloseHandle() {
-  if (INVALID_HANDLE_VALUE != usb_handle_) {
-    ::CloseHandle(usb_handle_);
-    usb_handle_ = INVALID_HANDLE_VALUE;
-  }
-
-  return AdbEndpointObject::CloseHandle();
-}
+/*
+ * Copyright (C) 2009 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+/** \file
+  This file consists of implementation of class AdbLegacyEndpointObject that
+  encapsulates a handle opened to an endpoint on our device controlled by
+  a custom (legacy) USB driver.
+*/
+
+#include "stdafx.h"
+#include "adb_api_legacy.h"
+#include "adb_legacy_endpoint_object.h"
+#include "adb_legacy_io_completion.h"
+#include "adb_helper_routines.h"
+
+AdbLegacyEndpointObject::AdbLegacyEndpointObject(
+    AdbLegacyInterfaceObject* parent_interf,
+    UCHAR endpoint_id,
+    UCHAR endpoint_index)
+    : AdbEndpointObject(parent_interf, endpoint_id, endpoint_index),
+      usb_handle_(INVALID_HANDLE_VALUE) {
+}
+
+AdbLegacyEndpointObject::~AdbLegacyEndpointObject() {
+  if (INVALID_HANDLE_VALUE != usb_handle_) {
+    ::CloseHandle(usb_handle_);
+  }
+}
+
+ADBAPIHANDLE AdbLegacyEndpointObject::CommonAsyncReadWrite(
+    bool is_read,
+    void* buffer,
+    ULONG bytes_to_transfer,
+    ULONG* bytes_transferred,
+    HANDLE event_handle,
+    ULONG time_out) {
+  if (NULL != bytes_transferred) {
+    *bytes_transferred = 0;
+  }
+
+  if (!IsOpened()) {
+    SetLastError(ERROR_INVALID_HANDLE);
+    return NULL;
+  }
+
+  bool is_ioctl_write = is_read ? false : (0 != time_out);
+
+  // Create completion i/o object
+  AdbLegacyIOCompletion* adb_io_completion = NULL;
+
+  try {
+    adb_io_completion = new AdbLegacyIOCompletion(this,
+                                                  bytes_to_transfer,
+                                                  event_handle,
+                                                  is_ioctl_write);
+  } catch (... ) {
+    // We don't expect exceptions other than OOM thrown here.
+    SetLastError(ERROR_OUTOFMEMORY);
+    return NULL;
+  }
+
+  // Create a handle for it
+  ADBAPIHANDLE ret = adb_io_completion->CreateHandle();
+  ULONG transferred = 0;
+  if (NULL != ret) {
+    BOOL res = TRUE;
+    if (0 == time_out) {
+      // Go the read / write file way
+      res = is_read ? ReadFile(usb_handle(),
+                               buffer,
+                               bytes_to_transfer,
+                               &transferred,
+                               adb_io_completion->overlapped()) :
+                      WriteFile(usb_handle(),
+                                buffer,
+                                bytes_to_transfer,
+                                &transferred,
+                                adb_io_completion->overlapped());
+    } else {
+      // Go IOCTL way
+      AdbBulkTransfer transfer_param;
+      transfer_param.time_out = time_out;
+      transfer_param.transfer_size = is_read ? 0 : bytes_to_transfer;
+      transfer_param.SetWriteBuffer(is_read ? NULL : buffer);
+
+      res = DeviceIoControl(usb_handle(),
+        is_read ? ADB_IOCTL_BULK_READ : ADB_IOCTL_BULK_WRITE,
+        &transfer_param, sizeof(transfer_param),
+        is_read ? buffer : adb_io_completion->transferred_bytes_ptr(),
+        is_read ? bytes_to_transfer : sizeof(ULONG),
+        &transferred,
+        adb_io_completion->overlapped());
+    }
+
+    if (NULL != bytes_transferred) {
+      *bytes_transferred = transferred;
+    }
+
+    ULONG error = GetLastError();
+    if (!res && (ERROR_IO_PENDING != error)) {
+      // I/O failed immediatelly. We need to close i/o completion object
+      // before we return NULL to the caller.
+      adb_io_completion->CloseHandle();
+      ret = NULL;
+      SetLastError(error);
+    }
+  }
+
+  // Offseting 'new'
+  adb_io_completion->Release();
+
+  return ret;
+}
+
+bool AdbLegacyEndpointObject::CommonSyncReadWrite(bool is_read,
+                                                  void* buffer,
+                                                  ULONG bytes_to_transfer,
+                                                  ULONG* bytes_transferred,
+                                                  ULONG time_out) {
+  if (NULL != bytes_transferred) {
+    *bytes_transferred = 0;
+  }
+
+  if (!IsOpened()) {
+    SetLastError(ERROR_INVALID_HANDLE);
+    return false;
+  }
+
+  bool is_ioctl_write = is_read ? false : (0 != time_out);
+
+  // This is synchronous I/O. Since we always open I/O items for
+  // overlapped I/O we're obligated to always provide OVERLAPPED
+  // structure to read / write routines. Prepare it now.
+  OVERLAPPED overlapped;
+  ZeroMemory(&overlapped, sizeof(overlapped));
+
+  BOOL ret = TRUE;
+  ULONG ioctl_write_transferred = 0;
+  if (0 == time_out) {
+    // Go the read / write file way
+    ret = is_read ?
+      ReadFile(usb_handle(), buffer, bytes_to_transfer, bytes_transferred, &overlapped) :
+      WriteFile(usb_handle(), buffer, bytes_to_transfer, bytes_transferred, &overlapped);
+  } else {
+    // Go IOCTL way
+    AdbBulkTransfer transfer_param;
+    transfer_param.time_out = time_out;
+    transfer_param.transfer_size = is_read ? 0 : bytes_to_transfer;
+    transfer_param.SetWriteBuffer(is_read ? NULL : buffer);
+
+    ULONG tmp;
+    ret = DeviceIoControl(usb_handle(),
+      is_read ? ADB_IOCTL_BULK_READ : ADB_IOCTL_BULK_WRITE,
+      &transfer_param, sizeof(transfer_param),
+      is_read ? buffer : &ioctl_write_transferred,
+      is_read ? bytes_to_transfer : sizeof(ULONG),
+      &tmp,
+      &overlapped);
+  }
+
+  // Lets see the result
+  if (!ret && (ERROR_IO_PENDING != GetLastError())) {
+    // I/O failed.
+    return false;
+  }
+
+  // Lets wait till I/O completes
+  ULONG transferred = 0;
+  ret = GetOverlappedResult(usb_handle(), &overlapped, &transferred, TRUE);
+  if (ret && (NULL != bytes_transferred)) {
+    *bytes_transferred = is_ioctl_write ? ioctl_write_transferred :
+                                          transferred;
+  }
+
+  return ret ? true : false;
+}
+
+ADBAPIHANDLE AdbLegacyEndpointObject::CreateHandle(
+    const wchar_t* item_path,
+    AdbOpenAccessType access_type,
+    AdbOpenSharingMode share_mode) {
+  // Convert access / share parameters into CreateFile - compatible
+  ULONG desired_access;
+  ULONG desired_sharing;
+
+  if (!GetSDKComplientParam(access_type, share_mode,
+                            &desired_access, &desired_sharing)) {
+    return NULL;
+  }
+
+  // Open USB handle
+  usb_handle_ = CreateFileW(item_path,
+                           desired_access,
+                           share_mode,
+                           NULL,
+                           OPEN_EXISTING,
+                           FILE_FLAG_OVERLAPPED,  // Always overlapped!
+                           NULL);
+  if (INVALID_HANDLE_VALUE == usb_handle_) {
+    return NULL;
+  }
+
+  // Create ADB handle
+  ADBAPIHANDLE ret = AdbObjectHandle::CreateHandle();
+
+  if (NULL == ret) {
+    // If creation of ADB handle failed we have to close USB handle too.
+    ULONG error = GetLastError();
+    ::CloseHandle(usb_handle());
+    usb_handle_ = INVALID_HANDLE_VALUE;
+    SetLastError(error);
+  }
+
+  return ret;
+}
+
+bool AdbLegacyEndpointObject::CloseHandle() {
+  if (INVALID_HANDLE_VALUE != usb_handle_) {
+    ::CloseHandle(usb_handle_);
+    usb_handle_ = INVALID_HANDLE_VALUE;
+  }
+
+  return AdbEndpointObject::CloseHandle();
+}
diff --git a/host/windows/usb/api/adb_legacy_interface.cpp b/host/windows/usb/api/adb_legacy_interface.cpp
index 9eab9bd56..369912c79 100755
--- a/host/windows/usb/api/adb_legacy_interface.cpp
+++ b/host/windows/usb/api/adb_legacy_interface.cpp
@@ -1,324 +1,318 @@
-/*
- * Copyright (C) 2009 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-/** \file
-  This file consists of implementation of class AdbLegacyInterfaceObject
-  that encapsulates an interface on our USB device that is accessible
-*/
-
-#include "stdafx.h"
-#include "adb_api_legacy.h"
-#include "adb_legacy_interface.h"
-#include "adb_legacy_endpoint_object.h"
-
-AdbLegacyInterfaceObject::AdbLegacyInterfaceObject(const wchar_t* interf_name)
-    : AdbInterfaceObject(interf_name),
-      def_read_endpoint_(0xFF),
-      read_endpoint_id_(0xFF),
-      def_write_endpoint_(0xFF),
-      write_endpoint_id_(0xFF) {
-}
-
-AdbLegacyInterfaceObject::~AdbLegacyInterfaceObject() {
-}
-
-ADBAPIHANDLE AdbLegacyInterfaceObject::CreateHandle() {
-  // Open USB device for this intefface
-  HANDLE usb_device_handle = CreateFile(interface_name().c_str(),
-                                        GENERIC_READ | GENERIC_WRITE,
-                                        FILE_SHARE_READ | FILE_SHARE_WRITE,
-                                        NULL,
-                                        OPEN_EXISTING,
-                                        0,
-                                        NULL);
-  if (INVALID_HANDLE_VALUE == usb_device_handle) {
-    return NULL;
-  }
-
-  // Now, we ensured that our usb device / interface is up and running.
-  // Lets collect device, interface and pipe information
-  bool ok = true;
-  if (!CacheUsbDeviceDescriptor(usb_device_handle) ||
-      !CacheUsbConfigurationDescriptor(usb_device_handle) ||
-      !CacheUsbInterfaceDescriptor(usb_device_handle)) {
-    ok = false;
-  }
-
-  // Preserve error accross handle close
-  ULONG error = ok ? NO_ERROR : GetLastError();
-
-  ::CloseHandle(usb_device_handle);
-
-  if (NO_ERROR != error) {
-    SetLastError(error);
-  }
-
-  if (!ok) {
-    return false;
-  }
-
-  // Save indexes and IDs for bulk read / write endpoints. We will use them to
-  // convert ADB_QUERY_BULK_WRITE_ENDPOINT_INDEX and
-  // ADB_QUERY_BULK_READ_ENDPOINT_INDEX into actual endpoint indexes and IDs.
-  for (UCHAR endpoint = 0; endpoint < usb_interface_descriptor_.bNumEndpoints;
-       endpoint++) {
-    // Get endpoint information
-    AdbEndpointInformation pipe_info;
-    if (!GetEndpointInformation(endpoint, &pipe_info)) {
-      return false;
-    }
-
-    if (AdbEndpointTypeBulk == pipe_info.endpoint_type) {
-      // This is a bulk endpoint. Cache its index and ID.
-      if (0 != (pipe_info.endpoint_address & USB_ENDPOINT_DIRECTION_MASK)) {
-        // Use this endpoint as default bulk read endpoint
-        ATLASSERT(0xFF == def_read_endpoint_);
-        def_read_endpoint_ = endpoint;
-        read_endpoint_id_ = pipe_info.endpoint_address;
-      } else {
-        // Use this endpoint as default bulk write endpoint
-        ATLASSERT(0xFF == def_write_endpoint_);
-        def_write_endpoint_ = endpoint;
-        write_endpoint_id_ = pipe_info.endpoint_address;
-      }
-    }
-  }
-
-  return AdbObjectHandle::CreateHandle();
-}
-
-bool AdbLegacyInterfaceObject::GetSerialNumber(void* buffer,
-                                               unsigned long* buffer_char_size,
-                                               bool ansi) {
-  if (!IsOpened()) {
-    SetLastError(ERROR_INVALID_HANDLE);
-    return false;
-  }
-
-  // Open USB device for this intefface
-  HANDLE usb_device_handle = CreateFile(interface_name().c_str(),
-                                        GENERIC_READ,
-                                        FILE_SHARE_READ | FILE_SHARE_WRITE,
-                                        NULL,
-                                        OPEN_EXISTING,
-                                        0,
-                                        NULL);
-  if (INVALID_HANDLE_VALUE == usb_device_handle) {
-    return NULL;
-  }
-
-  WCHAR serial_number[512];
-
-  // Send IOCTL
-  DWORD ret_bytes = 0;
-  BOOL ret = DeviceIoControl(usb_device_handle,
-                             ADB_IOCTL_GET_SERIAL_NUMBER,
-                             NULL, 0,
-                             serial_number, sizeof(serial_number),
-                             &ret_bytes,
-                             NULL);
-
-  // Preserve error accross CloseHandle
-  ULONG error = ret ? NO_ERROR : GetLastError();
-
-  ::CloseHandle(usb_device_handle);
-
-  if (NO_ERROR != error) {
-    SetLastError(error);
-    return false;
-  }
-
-  unsigned long str_len =
-    static_cast<unsigned long>(wcslen(serial_number) + 1);
-
-  if ((NULL == buffer) || (*buffer_char_size < str_len)) {
-    *buffer_char_size = str_len;
-    SetLastError(ERROR_INSUFFICIENT_BUFFER);
-    return false;
-  }
-
-  if (!ansi) {
-    // If user asked for wide char name just return it
-    wcscpy(reinterpret_cast<wchar_t*>(buffer), serial_number);
-    return true;
-  }
-
-  // We need to convert name from wide char to ansi string
-  int res = WideCharToMultiByte(CP_ACP,
-                                0,
-                                serial_number,
-                                static_cast<int>(str_len),
-                                reinterpret_cast<PSTR>(buffer),
-                                static_cast<int>(*buffer_char_size),
-                                NULL,
-                                NULL);
-  return (res != 0);
-}
-
-bool AdbLegacyInterfaceObject::GetEndpointInformation(
-    UCHAR endpoint_index,
-    AdbEndpointInformation* info) {
-  // Open USB device for this intefface
-  HANDLE usb_device_handle = CreateFile(interface_name().c_str(),
-                                        GENERIC_READ,
-                                        FILE_SHARE_READ | FILE_SHARE_WRITE,
-                                        NULL,
-                                        OPEN_EXISTING,
-                                        0,
-                                        NULL);
-  if (INVALID_HANDLE_VALUE == usb_device_handle) {
-    return NULL;
-  }
-
-  // Init ICTL param
-  AdbQueryEndpointInformation param;
-  param.endpoint_index = endpoint_index;
-
-  // Send IOCTL
-  DWORD ret_bytes = 0;
-  BOOL ret = DeviceIoControl(usb_device_handle,
-                             ADB_IOCTL_GET_ENDPOINT_INFORMATION,
-                             &param, sizeof(param),
-                             info, sizeof(AdbEndpointInformation),
-                             &ret_bytes,
-                             NULL);
-  ATLASSERT(!ret || (sizeof(AdbEndpointInformation) == ret_bytes));
-
-  // Preserve error accross CloseHandle
-  ULONG error = ret ? NO_ERROR : GetLastError();
-
-  ::CloseHandle(usb_device_handle);
-
-  if (NO_ERROR != error) {
-    SetLastError(error);
-  }
-
-  return ret ? true : false;
-}
-
-ADBAPIHANDLE AdbLegacyInterfaceObject::OpenEndpoint(
-    UCHAR endpoint_index,
-    AdbOpenAccessType access_type,
-    AdbOpenSharingMode sharing_mode) {
-  // Convert index into name and ID.
-  std::wstring endpoint_name;
-  UCHAR endpoint_id;
-
-  try {
-    if ((ADB_QUERY_BULK_READ_ENDPOINT_INDEX == endpoint_index) ||
-        (def_read_endpoint_ == endpoint_index)) {
-      endpoint_name = DEVICE_BULK_READ_PIPE_NAME;
-      endpoint_id = read_endpoint_id_;
-      endpoint_index = def_read_endpoint_;
-    } else if ((ADB_QUERY_BULK_WRITE_ENDPOINT_INDEX == endpoint_index) ||
-               (def_write_endpoint_ == endpoint_index)) {
-      endpoint_name = DEVICE_BULK_WRITE_PIPE_NAME;
-      endpoint_id = write_endpoint_id_;
-      endpoint_index = def_write_endpoint_;
-    } else {
-      SetLastError(ERROR_INVALID_PARAMETER);
-      return false;
-    }
-  } catch (...) {
-    // We don't expect exceptions other than OOM thrown here.
-    SetLastError(ERROR_OUTOFMEMORY);
-    return NULL;
-  }
-
-  return OpenEndpoint(endpoint_name.c_str(), endpoint_id, endpoint_index,
-                      access_type, sharing_mode);
-}
-
-ADBAPIHANDLE AdbLegacyInterfaceObject::OpenEndpoint(
-    const wchar_t* endpoint_name,
-    UCHAR endpoint_id,
-    UCHAR endpoint_index,
-    AdbOpenAccessType access_type,
-    AdbOpenSharingMode sharing_mode) {
-  if (!IsOpened()) {
-    SetLastError(ERROR_INVALID_HANDLE);
-    return false;
-  }
-
-  AdbLegacyEndpointObject* adb_endpoint = NULL;
-
-  try {
-    adb_endpoint =
-        new AdbLegacyEndpointObject(this, endpoint_id, endpoint_index);
-  } catch (...) {
-    // We don't expect exceptions other than OOM thrown here.
-    SetLastError(ERROR_OUTOFMEMORY);
-    return NULL;
-  }
-
-  // Build full path to the object
-  std::wstring endpoint_path = interface_name();
-  endpoint_path += L"\\";
-  endpoint_path += endpoint_name;
-
-  ADBAPIHANDLE ret = adb_endpoint->CreateHandle(endpoint_path.c_str(),
-                                                access_type,
-                                                sharing_mode);
-
-  adb_endpoint->Release();
-
-  return ret;
-}
-
-bool AdbLegacyInterfaceObject::CacheUsbDeviceDescriptor(
-    HANDLE usb_device_handle) {
-  DWORD ret_bytes = 0;
-  BOOL ret = DeviceIoControl(usb_device_handle,
-                             ADB_IOCTL_GET_USB_DEVICE_DESCRIPTOR,
-                             NULL, 0,
-                             &usb_device_descriptor_,
-                             sizeof(usb_device_descriptor_),
-                             &ret_bytes,
-                             NULL);
-  ATLASSERT(!ret || (sizeof(USB_DEVICE_DESCRIPTOR) == ret_bytes));
-
-  return ret ? true : false;
-}
-
-bool AdbLegacyInterfaceObject::CacheUsbConfigurationDescriptor(
-    HANDLE usb_device_handle) {
-  DWORD ret_bytes = 0;
-  BOOL ret = DeviceIoControl(usb_device_handle,
-                             ADB_IOCTL_GET_USB_CONFIGURATION_DESCRIPTOR,
-                             NULL, 0,
-                             &usb_config_descriptor_,
-                             sizeof(usb_config_descriptor_),
-                             &ret_bytes,
-                             NULL);
-  ATLASSERT(!ret || (sizeof(USB_CONFIGURATION_DESCRIPTOR) == ret_bytes));
-
-  return ret ? true : false;
-}
-
-bool AdbLegacyInterfaceObject::CacheUsbInterfaceDescriptor(
-    HANDLE usb_device_handle) {
-  DWORD ret_bytes = 0;
-  BOOL ret = DeviceIoControl(usb_device_handle,
-                             ADB_IOCTL_GET_USB_INTERFACE_DESCRIPTOR,
-                             NULL, 0,
-                             &usb_interface_descriptor_,
-                             sizeof(usb_interface_descriptor_),
-                             &ret_bytes,
-                             NULL);
-  ATLASSERT(!ret || (sizeof(USB_INTERFACE_DESCRIPTOR) == ret_bytes));
-
-  return ret ? true : false;
-}
+/*
+ * Copyright (C) 2009 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+/** \file
+  This file consists of implementation of class AdbLegacyInterfaceObject
+  that encapsulates an interface on our USB device that is accessible
+*/
+
+#include "stdafx.h"
+#include "adb_api_legacy.h"
+#include "adb_legacy_interface.h"
+#include "adb_legacy_endpoint_object.h"
+
+AdbLegacyInterfaceObject::AdbLegacyInterfaceObject(const wchar_t* interf_name)
+    : AdbInterfaceObject(interf_name),
+      def_read_endpoint_(0xFF),
+      read_endpoint_id_(0xFF),
+      def_write_endpoint_(0xFF),
+      write_endpoint_id_(0xFF) {
+}
+
+AdbLegacyInterfaceObject::~AdbLegacyInterfaceObject() {
+}
+
+ADBAPIHANDLE AdbLegacyInterfaceObject::CreateHandle() {
+  // Open USB device for this intefface
+  HANDLE usb_device_handle = CreateFileW(interface_name().c_str(),
+                                        GENERIC_READ | GENERIC_WRITE,
+                                        FILE_SHARE_READ | FILE_SHARE_WRITE,
+                                        NULL,
+                                        OPEN_EXISTING,
+                                        0,
+                                        NULL);
+  if (INVALID_HANDLE_VALUE == usb_device_handle) {
+    return NULL;
+  }
+
+  // Now, we ensured that our usb device / interface is up and running.
+  // Lets collect device, interface and pipe information
+  bool ok = true;
+  if (!CacheUsbDeviceDescriptor(usb_device_handle) ||
+      !CacheUsbConfigurationDescriptor(usb_device_handle) ||
+      !CacheUsbInterfaceDescriptor(usb_device_handle)) {
+    ok = false;
+  }
+
+  // Preserve error accross handle close
+  ULONG error = ok ? NO_ERROR : GetLastError();
+
+  ::CloseHandle(usb_device_handle);
+
+  if (NO_ERROR != error) {
+    SetLastError(error);
+  }
+
+  if (!ok) {
+    return NULL;
+  }
+
+  // Save indexes and IDs for bulk read / write endpoints. We will use them to
+  // convert ADB_QUERY_BULK_WRITE_ENDPOINT_INDEX and
+  // ADB_QUERY_BULK_READ_ENDPOINT_INDEX into actual endpoint indexes and IDs.
+  for (UCHAR endpoint = 0; endpoint < usb_interface_descriptor_.bNumEndpoints;
+       endpoint++) {
+    // Get endpoint information
+    AdbEndpointInformation pipe_info;
+    if (!GetEndpointInformation(endpoint, &pipe_info)) {
+      return NULL;
+    }
+
+    if (AdbEndpointTypeBulk == pipe_info.endpoint_type) {
+      // This is a bulk endpoint. Cache its index and ID.
+      if (0 != (pipe_info.endpoint_address & USB_ENDPOINT_DIRECTION_MASK)) {
+        // Use this endpoint as default bulk read endpoint
+        def_read_endpoint_ = endpoint;
+        read_endpoint_id_ = pipe_info.endpoint_address;
+      } else {
+        // Use this endpoint as default bulk write endpoint
+        def_write_endpoint_ = endpoint;
+        write_endpoint_id_ = pipe_info.endpoint_address;
+      }
+    }
+  }
+
+  return AdbObjectHandle::CreateHandle();
+}
+
+bool AdbLegacyInterfaceObject::GetSerialNumber(void* buffer,
+                                               unsigned long* buffer_char_size,
+                                               bool ansi) {
+  if (!IsOpened()) {
+    SetLastError(ERROR_INVALID_HANDLE);
+    return false;
+  }
+
+  // Open USB device for this intefface
+  HANDLE usb_device_handle = CreateFileW(interface_name().c_str(),
+                                        GENERIC_READ,
+                                        FILE_SHARE_READ | FILE_SHARE_WRITE,
+                                        NULL,
+                                        OPEN_EXISTING,
+                                        0,
+                                        NULL);
+  if (INVALID_HANDLE_VALUE == usb_device_handle) {
+    return false;
+  }
+
+  WCHAR serial_number[512];
+
+  // Send IOCTL
+  DWORD ret_bytes = 0;
+  BOOL ret = DeviceIoControl(usb_device_handle,
+                             ADB_IOCTL_GET_SERIAL_NUMBER,
+                             NULL, 0,
+                             serial_number, sizeof(serial_number),
+                             &ret_bytes,
+                             NULL);
+
+  // Preserve error accross CloseHandle
+  ULONG error = ret ? NO_ERROR : GetLastError();
+
+  ::CloseHandle(usb_device_handle);
+
+  if (NO_ERROR != error) {
+    SetLastError(error);
+    return false;
+  }
+
+  unsigned long str_len =
+    static_cast<unsigned long>(wcslen(serial_number) + 1);
+
+  if ((NULL == buffer) || (*buffer_char_size < str_len)) {
+    *buffer_char_size = str_len;
+    SetLastError(ERROR_INSUFFICIENT_BUFFER);
+    return false;
+  }
+
+  if (!ansi) {
+    // If user asked for wide char name just return it
+    wcscpy(reinterpret_cast<wchar_t*>(buffer), serial_number);
+    return false;
+  }
+
+  // We need to convert name from wide char to ansi string
+  int res = WideCharToMultiByte(CP_ACP,
+                                0,
+                                serial_number,
+                                static_cast<int>(str_len),
+                                reinterpret_cast<PSTR>(buffer),
+                                static_cast<int>(*buffer_char_size),
+                                NULL,
+                                NULL);
+  return (res != 0);
+}
+
+bool AdbLegacyInterfaceObject::GetEndpointInformation(
+    UCHAR endpoint_index,
+    AdbEndpointInformation* info) {
+  // Open USB device for this intefface
+  HANDLE usb_device_handle = CreateFileW(interface_name().c_str(),
+                                        GENERIC_READ,
+                                        FILE_SHARE_READ | FILE_SHARE_WRITE,
+                                        NULL,
+                                        OPEN_EXISTING,
+                                        0,
+                                        NULL);
+  if (INVALID_HANDLE_VALUE == usb_device_handle) {
+    return NULL;
+  }
+
+  // Init ICTL param
+  AdbQueryEndpointInformation param;
+  param.endpoint_index = endpoint_index;
+
+  // Send IOCTL
+  DWORD ret_bytes = 0;
+  BOOL ret = DeviceIoControl(usb_device_handle,
+                             ADB_IOCTL_GET_ENDPOINT_INFORMATION,
+                             &param, sizeof(param),
+                             info, sizeof(AdbEndpointInformation),
+                             &ret_bytes,
+                             NULL);
+
+  // Preserve error accross CloseHandle
+  ULONG error = ret ? NO_ERROR : GetLastError();
+
+  ::CloseHandle(usb_device_handle);
+
+  if (NO_ERROR != error) {
+    SetLastError(error);
+  }
+
+  return ret ? true : false;
+}
+
+ADBAPIHANDLE AdbLegacyInterfaceObject::OpenEndpoint(
+    UCHAR endpoint_index,
+    AdbOpenAccessType access_type,
+    AdbOpenSharingMode sharing_mode) {
+  // Convert index into name and ID.
+  std::wstring endpoint_name;
+  UCHAR endpoint_id;
+
+  try {
+    if ((ADB_QUERY_BULK_READ_ENDPOINT_INDEX == endpoint_index) ||
+        (def_read_endpoint_ == endpoint_index)) {
+      endpoint_name = DEVICE_BULK_READ_PIPE_NAME;
+      endpoint_id = read_endpoint_id_;
+      endpoint_index = def_read_endpoint_;
+    } else if ((ADB_QUERY_BULK_WRITE_ENDPOINT_INDEX == endpoint_index) ||
+               (def_write_endpoint_ == endpoint_index)) {
+      endpoint_name = DEVICE_BULK_WRITE_PIPE_NAME;
+      endpoint_id = write_endpoint_id_;
+      endpoint_index = def_write_endpoint_;
+    } else {
+      SetLastError(ERROR_INVALID_PARAMETER);
+      return NULL;
+    }
+  } catch (...) {
+    // We don't expect exceptions other than OOM thrown here.
+    SetLastError(ERROR_OUTOFMEMORY);
+    return NULL;
+  }
+
+  return OpenEndpoint(endpoint_name.c_str(), endpoint_id, endpoint_index,
+                      access_type, sharing_mode);
+}
+
+ADBAPIHANDLE AdbLegacyInterfaceObject::OpenEndpoint(
+    const wchar_t* endpoint_name,
+    UCHAR endpoint_id,
+    UCHAR endpoint_index,
+    AdbOpenAccessType access_type,
+    AdbOpenSharingMode sharing_mode) {
+  if (!IsOpened()) {
+    SetLastError(ERROR_INVALID_HANDLE);
+    return NULL;
+  }
+
+  AdbLegacyEndpointObject* adb_endpoint = NULL;
+
+  try {
+    adb_endpoint =
+        new AdbLegacyEndpointObject(this, endpoint_id, endpoint_index);
+  } catch (...) {
+    // We don't expect exceptions other than OOM thrown here.
+    SetLastError(ERROR_OUTOFMEMORY);
+    return NULL;
+  }
+
+  // Build full path to the object
+  std::wstring endpoint_path = interface_name();
+  endpoint_path += L"\\";
+  endpoint_path += endpoint_name;
+
+  ADBAPIHANDLE ret = adb_endpoint->CreateHandle(endpoint_path.c_str(),
+                                                access_type,
+                                                sharing_mode);
+
+  adb_endpoint->Release();
+
+  return ret;
+}
+
+bool AdbLegacyInterfaceObject::CacheUsbDeviceDescriptor(
+    HANDLE usb_device_handle) {
+  DWORD ret_bytes = 0;
+  BOOL ret = DeviceIoControl(usb_device_handle,
+                             ADB_IOCTL_GET_USB_DEVICE_DESCRIPTOR,
+                             NULL, 0,
+                             &usb_device_descriptor_,
+                             sizeof(usb_device_descriptor_),
+                             &ret_bytes,
+                             NULL);
+
+  return ret ? true : false;
+}
+
+bool AdbLegacyInterfaceObject::CacheUsbConfigurationDescriptor(
+    HANDLE usb_device_handle) {
+  DWORD ret_bytes = 0;
+  BOOL ret = DeviceIoControl(usb_device_handle,
+                             ADB_IOCTL_GET_USB_CONFIGURATION_DESCRIPTOR,
+                             NULL, 0,
+                             &usb_config_descriptor_,
+                             sizeof(usb_config_descriptor_),
+                             &ret_bytes,
+                             NULL);
+
+  return ret ? true : false;
+}
+
+bool AdbLegacyInterfaceObject::CacheUsbInterfaceDescriptor(
+    HANDLE usb_device_handle) {
+  DWORD ret_bytes = 0;
+  BOOL ret = DeviceIoControl(usb_device_handle,
+                             ADB_IOCTL_GET_USB_INTERFACE_DESCRIPTOR,
+                             NULL, 0,
+                             &usb_interface_descriptor_,
+                             sizeof(usb_interface_descriptor_),
+                             &ret_bytes,
+                             NULL);
+
+  return ret ? true : false;
+}
diff --git a/host/windows/usb/api/adb_legacy_io_completion.h b/host/windows/usb/api/adb_legacy_io_completion.h
index 743219e4d..f0216bc3c 100755
--- a/host/windows/usb/api/adb_legacy_io_completion.h
+++ b/host/windows/usb/api/adb_legacy_io_completion.h
@@ -1,115 +1,114 @@
-/*
- * Copyright (C) 2009 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-#ifndef ANDROID_USB_API_ADB_LEGACY_IO_COMPLETION_H__
-#define ANDROID_USB_API_ADB_LEGACY_IO_COMPLETION_H__
-/** \file
-  This file consists of declaration of class AdbLegacyIOCompletion that
-  encapsulates a wrapper around OVERLAPPED Win32 structure returned from
-  asynchronous I/O requests issued via legacy USB API.
-*/
-
-#include "adb_io_completion.h"
-#include "adb_legacy_endpoint_object.h"
-
-/** \brief Encapsulates a wrapper around OVERLAPPED Win32 structure returned
-  from asynchronous I/O requests issued via legacy USB API.
-
-  A handle to this object is returned to the caller of each successful
-  asynchronous I/O request. Just like all other handles this handle
-  must be closed after it's no longer needed.
-*/
-class AdbLegacyIOCompletion : public AdbIOCompletion {
- public:
-  /** \brief Constructs the object.
-
-    @param[in] parent_io_obj Parent legacy endpoint that created this
-           instance.
-    @param[in] expected_trans_size Number of bytes expected to be transferred
-          with the I/O.
-    @param[in] event_hndl Event handle that should be signaled when I/O
-           completes. Can be NULL. If it's not NULL this handle will be
-           used to initialize OVERLAPPED structure for this object.
-    @param[in] is_write_ctl Flag indicating whether or not this completion
-           object is created for ADB_IOCTL_BULK_WRITE I/O.
-  */
-  AdbLegacyIOCompletion(AdbLegacyEndpointObject* parent_io_obj,
-                        ULONG expected_trans_size,
-                        HANDLE event_hndl,
-                        bool is_write_ctl);
-
- protected:
-  /** \brief Destructs the object.
-
-    We hide destructor in order to prevent ourseves from accidentaly allocating
-    instances on the stack. If such attemp occur, compiler will error.
-  */
-  virtual ~AdbLegacyIOCompletion();
-
-  //
-  // Abstract overrides
-  //
-
- public:
-  /** \brief Gets overlapped I/O result
-
-    This method uses GetOverlappedResult to get results of the overlapped I/O
-    operation.
-    @param[out] ovl_data Buffer for the copy of this object's OVERLAPPED
-           structure. Can be NULL.
-    @param[out] bytes_transferred Pointer to a variable that receives the
-           number of bytes that were actually transferred by a read or write
-           operation. See SDK doc on GetOvelappedResult for more information.
-           Unlike regular GetOvelappedResult call this parameter can be NULL.
-    @param[in] wait If this parameter is true, the method does not return
-           until the operation has been completed. If this parameter is false
-           and the operation is still pending, the method returns false and
-           the GetLastError function returns ERROR_IO_INCOMPLETE.
-    @return true if I/O has been completed or false on failure or if request
-           is not yet completed. If false is returned GetLastError() provides
-           extended error information. If GetLastError returns
-           ERROR_IO_INCOMPLETE it means that I/O is not yet completed.
-  */
-  virtual bool GetOvelappedIoResult(LPOVERLAPPED ovl_data,
-                                    ULONG* bytes_transferred,
-                                    bool wait);
-
- public:
-  /// Gets parent legacy endpoint.
-  AdbLegacyEndpointObject* parent_legacy_io_object() const {
-    return reinterpret_cast<AdbLegacyEndpointObject*>(parent_io_object());
-  }
-
-  /// Gets write IOCTL flag.
-  bool is_write_ioctl() const {
-    return is_write_ioctl_;
-  }
-
-  /// Gets address for ADB_IOCTL_BULK_WRITE output buffer.
-  ULONG* transferred_bytes_ptr() {
-    ATLASSERT(is_write_ioctl());
-    return &transferred_bytes_;
-  }
-
- protected:
-  /// Recepient for number of transferred bytes in write IOCTL.
-  ULONG         transferred_bytes_;
-
-  /// Write IOCTL flag.
-  bool          is_write_ioctl_;
-};
-
-#endif  // ANDROID_USB_API_ADB_LEGACY_IO_COMPLETION_H__
+/*
+ * Copyright (C) 2009 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#ifndef ANDROID_USB_API_ADB_LEGACY_IO_COMPLETION_H__
+#define ANDROID_USB_API_ADB_LEGACY_IO_COMPLETION_H__
+/** \file
+  This file consists of declaration of class AdbLegacyIOCompletion that
+  encapsulates a wrapper around OVERLAPPED Win32 structure returned from
+  asynchronous I/O requests issued via legacy USB API.
+*/
+
+#include "adb_io_completion.h"
+#include "adb_legacy_endpoint_object.h"
+
+/** \brief Encapsulates a wrapper around OVERLAPPED Win32 structure returned
+  from asynchronous I/O requests issued via legacy USB API.
+
+  A handle to this object is returned to the caller of each successful
+  asynchronous I/O request. Just like all other handles this handle
+  must be closed after it's no longer needed.
+*/
+class AdbLegacyIOCompletion : public AdbIOCompletion {
+ public:
+  /** \brief Constructs the object.
+
+    @param[in] parent_io_obj Parent legacy endpoint that created this
+           instance.
+    @param[in] expected_trans_size Number of bytes expected to be transferred
+          with the I/O.
+    @param[in] event_hndl Event handle that should be signaled when I/O
+           completes. Can be NULL. If it's not NULL this handle will be
+           used to initialize OVERLAPPED structure for this object.
+    @param[in] is_write_ctl Flag indicating whether or not this completion
+           object is created for ADB_IOCTL_BULK_WRITE I/O.
+  */
+  AdbLegacyIOCompletion(AdbLegacyEndpointObject* parent_io_obj,
+                        ULONG expected_trans_size,
+                        HANDLE event_hndl,
+                        bool is_write_ctl);
+
+ protected:
+  /** \brief Destructs the object.
+
+    We hide destructor in order to prevent ourseves from accidentaly allocating
+    instances on the stack. If such attemp occur, compiler will error.
+  */
+  virtual ~AdbLegacyIOCompletion();
+
+  //
+  // Abstract overrides
+  //
+
+ public:
+  /** \brief Gets overlapped I/O result
+
+    This method uses GetOverlappedResult to get results of the overlapped I/O
+    operation.
+    @param[out] ovl_data Buffer for the copy of this object's OVERLAPPED
+           structure. Can be NULL.
+    @param[out] bytes_transferred Pointer to a variable that receives the
+           number of bytes that were actually transferred by a read or write
+           operation. See SDK doc on GetOvelappedResult for more information.
+           Unlike regular GetOvelappedResult call this parameter can be NULL.
+    @param[in] wait If this parameter is true, the method does not return
+           until the operation has been completed. If this parameter is false
+           and the operation is still pending, the method returns false and
+           the GetLastError function returns ERROR_IO_INCOMPLETE.
+    @return true if I/O has been completed or false on failure or if request
+           is not yet completed. If false is returned GetLastError() provides
+           extended error information. If GetLastError returns
+           ERROR_IO_INCOMPLETE it means that I/O is not yet completed.
+  */
+  virtual bool GetOvelappedIoResult(LPOVERLAPPED ovl_data,
+                                    ULONG* bytes_transferred,
+                                    bool wait);
+
+ public:
+  /// Gets parent legacy endpoint.
+  AdbLegacyEndpointObject* parent_legacy_io_object() const {
+    return reinterpret_cast<AdbLegacyEndpointObject*>(parent_io_object());
+  }
+
+  /// Gets write IOCTL flag.
+  bool is_write_ioctl() const {
+    return is_write_ioctl_;
+  }
+
+  /// Gets address for ADB_IOCTL_BULK_WRITE output buffer.
+  ULONG* transferred_bytes_ptr() {
+    return &transferred_bytes_;
+  }
+
+ protected:
+  /// Recepient for number of transferred bytes in write IOCTL.
+  ULONG         transferred_bytes_;
+
+  /// Write IOCTL flag.
+  bool          is_write_ioctl_;
+};
+
+#endif  // ANDROID_USB_API_ADB_LEGACY_IO_COMPLETION_H__
diff --git a/host/windows/usb/api/adb_object_handle.cpp b/host/windows/usb/api/adb_object_handle.cpp
index 751a0e24a..baba1510a 100644
--- a/host/windows/usb/api/adb_object_handle.cpp
+++ b/host/windows/usb/api/adb_object_handle.cpp
@@ -1,167 +1,155 @@
-/*
- * Copyright (C) 2006 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-/** \file
-  This file consists of implementation of a class AdbObjectHandle that
-  encapsulates an internal API object that is visible to the outside
-  of the API through a handle.
-*/
-
-#include "stdafx.h"
-#include "adb_api.h"
-#include "adb_object_handle.h"
-
-/// Global ADBAPIHANDLE -> AdbObjectHandle* map
-AdbObjectHandleMap      the_map;
-
-/// Locker for the AdbObjectHandleMap instance
-CComAutoCriticalSection the_map_locker;
-
-/// Next adb handle value generator
-ULONG_PTR               next_adb_handle_value = 0;
-
-AdbObjectHandle::AdbObjectHandle(AdbObjectType obj_type)
-    : adb_handle_(NULL),
-      object_type_(obj_type),
-      ref_count_(1) {
-  ATLASSERT(obj_type < AdbObjectTypeMax);
-}
-
-AdbObjectHandle::~AdbObjectHandle() {
-  ATLASSERT(0 == ref_count_);
-  ATLASSERT(NULL == adb_handle_);
-}
-
-LONG AdbObjectHandle::AddRef() {
-  ATLASSERT(ref_count_ > 0);
-  return InterlockedIncrement(&ref_count_);
-}
-
-LONG AdbObjectHandle::Release() {
-  ATLASSERT(ref_count_ > 0);
-  LONG ret = InterlockedDecrement(&ref_count_);
-  ATLASSERT(ret >= 0);
-  if (0 == ret) {
-    LastReferenceReleased();
-    delete this;
-  }
-  return ret;
-}
-
-ADBAPIHANDLE AdbObjectHandle::CreateHandle() {
-  ADBAPIHANDLE ret = NULL;
-
-  // We have to hold this lock while we're dealing with the handle
-  // and the table
-  the_map_locker.Lock();
-  
-  ATLASSERT(!IsOpened());
-
-  if (!IsOpened()) {
-    try {
-      // Generate next handle value
-      next_adb_handle_value++;
-      ret = reinterpret_cast<ADBAPIHANDLE>(next_adb_handle_value);
-
-      // Add ourselves to the map
-      the_map[ret] = this;
-
-      // Save handle, addref and return
-      adb_handle_ = ret;
-      AddRef();
-    } catch (...) {
-      ret = NULL;
-      SetLastError(ERROR_OUTOFMEMORY);
-    }
-  } else {
-    // Signaling that this object is already opened
-    SetLastError(ERROR_GEN_FAILURE);
-  }
-
-  the_map_locker.Unlock();
-
-  return ret;
-}
-
-bool AdbObjectHandle::CloseHandle() {
-  bool ret = false;
-
-  // Addref just in case that last reference to this object is being
-  // held in the map
-  AddRef();
-
-  the_map_locker.Lock();
-  
-  ATLASSERT(IsOpened());
-
-  if (IsOpened()) {
-    try {
-      // Look us up in the map.
-      AdbObjectHandleMap::iterator found = the_map.find(adb_handle());
-      ATLASSERT((found != the_map.end()) && (this == found->second));
-
-      if ((found != the_map.end()) && (this == found->second)) {
-        // Remove ourselves from the map, close and release the object
-        the_map.erase(found);
-        adb_handle_ = NULL;
-        Release();
-        ret = true;
-      } else {
-        SetLastError(ERROR_INVALID_HANDLE);
-      }
-    } catch (...) {
-      ret = false;
-      SetLastError(ERROR_OUTOFMEMORY);
-    }
-  } else {
-    SetLastError(ERROR_INVALID_HANDLE);
-  }
-
-  the_map_locker.Unlock();
-
-  Release();
-
-  return ret;
-}
-
-bool AdbObjectHandle::IsObjectOfType(AdbObjectType obj_type) const {
-  return (obj_type == object_type());
-}
-
-void AdbObjectHandle::LastReferenceReleased() {
-  ATLASSERT(!IsOpened());
-}
-
-AdbObjectHandle* AdbObjectHandle::Lookup(ADBAPIHANDLE adb_hndl) {
-  AdbObjectHandle* ret = NULL;
-
-  the_map_locker.Lock();
-
-  try {
-    // Look us up in the map.
-    AdbObjectHandleMap::iterator found = the_map.find(adb_hndl);
-    if (found != the_map.end()) {
-      ret = found->second;
-      ret->AddRef();
-    }
-  } catch (...) {
-    SetLastError(ERROR_OUTOFMEMORY);
-  }
-
-  the_map_locker.Unlock();
-
-  return ret;
-}
+/*
+ * Copyright (C) 2006 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+/** \file
+  This file consists of implementation of a class AdbObjectHandle that
+  encapsulates an internal API object that is visible to the outside
+  of the API through a handle.
+*/
+
+#include "stdafx.h"
+#include "adb_api.h"
+#include "adb_object_handle.h"
+
+/// Global ADBAPIHANDLE -> AdbObjectHandle* map
+AdbObjectHandleMap      the_map;
+
+/// Locker for the AdbObjectHandleMap instance
+// CComAutoCriticalSection the_map_locker;
+
+/// Next adb handle value generator
+ULONG_PTR               next_adb_handle_value = 0;
+
+AdbObjectHandle::AdbObjectHandle(AdbObjectType obj_type)
+    : adb_handle_(NULL),
+      object_type_(obj_type),
+      ref_count_(1) {
+}
+
+AdbObjectHandle::~AdbObjectHandle() {
+}
+
+LONG AdbObjectHandle::AddRef() {
+  return InterlockedIncrement(&ref_count_);
+}
+
+LONG AdbObjectHandle::Release() {
+  LONG ret = InterlockedDecrement(&ref_count_);
+  if (0 == ret) {
+    LastReferenceReleased();
+    delete this;
+  }
+  return ret;
+}
+
+ADBAPIHANDLE AdbObjectHandle::CreateHandle() {
+  ADBAPIHANDLE ret = NULL;
+
+  // We have to hold this lock while we're dealing with the handle
+  // and the table
+  // the_map_locker.Lock();
+  
+  if (!IsOpened()) {
+    try {
+      // Generate next handle value
+      next_adb_handle_value++;
+      ret = reinterpret_cast<ADBAPIHANDLE>(next_adb_handle_value);
+
+      // Add ourselves to the map
+      the_map[ret] = this;
+
+      // Save handle, addref and return
+      adb_handle_ = ret;
+      AddRef();
+    } catch (...) {
+      ret = NULL;
+      SetLastError(ERROR_OUTOFMEMORY);
+    }
+  } else {
+    // Signaling that this object is already opened
+    SetLastError(ERROR_GEN_FAILURE);
+  }
+
+  // the_map_locker.Unlock();
+
+  return ret;
+}
+
+bool AdbObjectHandle::CloseHandle() {
+  bool ret = false;
+
+  // Addref just in case that last reference to this object is being
+  // held in the map
+  AddRef();
+
+  // the_map_locker.Lock();
+  
+  if (IsOpened()) {
+    try {
+      // Look us up in the map.
+      AdbObjectHandleMap::iterator found = the_map.find(adb_handle());
+
+      if ((found != the_map.end()) && (this == found->second)) {
+        // Remove ourselves from the map, close and release the object
+        the_map.erase(found);
+        adb_handle_ = NULL;
+        Release();
+        ret = true;
+      } else {
+        SetLastError(ERROR_INVALID_HANDLE);
+      }
+    } catch (...) {
+      ret = false;
+      SetLastError(ERROR_OUTOFMEMORY);
+    }
+  } else {
+    SetLastError(ERROR_INVALID_HANDLE);
+  }
+
+  // the_map_locker.Unlock();
+
+  Release();
+
+  return ret;
+}
+
+bool AdbObjectHandle::IsObjectOfType(AdbObjectType obj_type) const {
+  return (obj_type == object_type());
+}
+
+void AdbObjectHandle::LastReferenceReleased() {
+}
+
+AdbObjectHandle* AdbObjectHandle::Lookup(ADBAPIHANDLE adb_hndl) {
+  AdbObjectHandle* ret = NULL;
+
+  // the_map_locker.Lock();
+
+  try {
+    // Look us up in the map.
+    AdbObjectHandleMap::iterator found = the_map.find(adb_hndl);
+    if (found != the_map.end()) {
+      ret = found->second;
+      ret->AddRef();
+    }
+  } catch (...) {
+    SetLastError(ERROR_OUTOFMEMORY);
+  }
+
+  // the_map_locker.Unlock();
+
+  return ret;
+}
diff --git a/host/windows/usb/api/stdafx.h b/host/windows/usb/api/stdafx.h
index d57bec74b..70f3067d7 100644
--- a/host/windows/usb/api/stdafx.h
+++ b/host/windows/usb/api/stdafx.h
@@ -1,79 +1,79 @@
-/*
- * Copyright (C) 2006 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-/** \file
-  Visual Studio generated include file for standard system include files, or
-  project specific include files that are used frequently, but are changed
-  infrequently.
-*/
-
-#pragma once
-
-#ifndef STRICT
-#define STRICT
-#endif
-
-// Modify the following defines if you have to target a platform prior to the ones specified below.
-// Refer to MSDN for the latest info on corresponding values for different platforms.
-#ifndef WINVER				// Allow use of features specific to Windows 95 and Windows NT 4 or later.
-#define WINVER 0x0500		// Change this to the appropriate value to target Windows 98 and Windows 2000 or later.
-#endif
-
-#ifndef _WIN32_WINNT		// Allow use of features specific to Windows NT 4 or later.
-#define _WIN32_WINNT 0x0500	// Change this to the appropriate value to target Windows 2000 or later.
-#endif						
-
-#ifndef _WIN32_WINDOWS		// Allow use of features specific to Windows 98 or later.
-#define _WIN32_WINDOWS 0x0500 // Change this to the appropriate value to target Windows Me or later.
-#endif
-
-#ifndef _WIN32_IE			// Allow use of features specific to IE 4.0 or later.
-#define _WIN32_IE 0x0501	// Change this to the appropriate value to target IE 5.0 or later.
-#endif
-
-// These defines prevent the MS header files from ejecting #pragma comment
-// statements with the manifest information of the used ATL, STL, and CRT
-#define _ATL_NOFORCE_MANIFEST
-#define _STL_NOFORCE_MANIFEST
-#define _CRT_NOFORCE_MANIFEST
-
-#define _ATL_APARTMENT_THREADED
-#define _ATL_NO_AUTOMATIC_NAMESPACE
-
-#define _ATL_CSTRING_EXPLICIT_CONSTRUCTORS	// some CString constructors will be explicit
-
-// turns off ATL's hiding of some common and often safely ignored warning messages
-#define _ATL_ALL_WARNINGS
-
-// #define WIN32_LEAN_AND_MEAN             // Exclude rarely-used stuff from Windows headers
-
-#include <windows.h>
-#pragma warning(disable: 4702)
-#pragma warning(disable: 4201)
-#include <atlbase.h>
-#include <winioctl.h>
-#include <setupapi.h>
-#include <vector>
-#include <map>
-#include <string>
-#pragma warning(default: 4201)
-#pragma warning(disable: 4200)
-#include <usbdi.h>
-#include <usb100.h>
-
-#include "resource.h"
-
-using namespace ATL;
+/*
+ * Copyright (C) 2006 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+/** \file
+  Visual Studio generated include file for standard system include files, or
+  project specific include files that are used frequently, but are changed
+  infrequently.
+*/
+
+#pragma once
+
+#ifndef STRICT
+#define STRICT
+#endif
+
+// Modify the following defines if you have to target a platform prior to the ones specified below.
+// Refer to MSDN for the latest info on corresponding values for different platforms.
+#ifndef WINVER				// Allow use of features specific to Windows 95 and Windows NT 4 or later.
+#define WINVER 0x0500		// Change this to the appropriate value to target Windows 98 and Windows 2000 or later.
+#endif
+
+#ifndef _WIN32_WINNT		// Allow use of features specific to Windows NT 4 or later.
+#define _WIN32_WINNT 0x0500	// Change this to the appropriate value to target Windows 2000 or later.
+#endif						
+
+#ifndef _WIN32_WINDOWS		// Allow use of features specific to Windows 98 or later.
+#define _WIN32_WINDOWS 0x0500 // Change this to the appropriate value to target Windows Me or later.
+#endif
+
+#ifndef _WIN32_IE			// Allow use of features specific to IE 4.0 or later.
+#define _WIN32_IE 0x0501	// Change this to the appropriate value to target IE 5.0 or later.
+#endif
+
+// These defines prevent the MS header files from ejecting #pragma comment
+// statements with the manifest information of the used ATL, STL, and CRT
+#define _ATL_NOFORCE_MANIFEST
+#define _STL_NOFORCE_MANIFEST
+#define _CRT_NOFORCE_MANIFEST
+
+#define _ATL_APARTMENT_THREADED
+#define _ATL_NO_AUTOMATIC_NAMESPACE
+
+#define _ATL_CSTRING_EXPLICIT_CONSTRUCTORS	// some CString constructors will be explicit
+
+// turns off ATL's hiding of some common and often safely ignored warning messages
+#define _ATL_ALL_WARNINGS
+
+// #define WIN32_LEAN_AND_MEAN             // Exclude rarely-used stuff from Windows headers
+
+#include <windows.h>
+#pragma warning(disable: 4702)
+#pragma warning(disable: 4201)
+//#include <atlbase.h>
+#include <winioctl.h>
+#include <setupapi.h>
+#include <vector>
+#include <map>
+#include <string>
+#pragma warning(default: 4201)
+#pragma warning(disable: 4200)
+#include <usbdi.h>
+#include <usb100.h>
+
+#include "Resource.h"
+
+//using namespace ATL;
